"use strict";function makeMap(str,expectsLowerCase){const map=Object.create(null);const list=str.split(",");for(let i=0;i<list.length;i++){map[list[i]]=true}return expectsLowerCase?val=>!!map[val.toLowerCase()]:val=>!!map[val]}const toDisplayString=val=>isString(val)?val:val==null?"":isArray(val)||isObject(val)&&(val.toString===objectToString||!isFunction(val.toString))?JSON.stringify(val,replacer,2):String(val);const replacer=(_key,val)=>{if(val&&val.__v_isRef){return replacer(_key,val.value)}else if(isMap(val)){return{[`Map(${val.size})`]:[...val.entries()].reduce(((entries,[key,val2])=>{entries[`${key} =>`]=val2;return entries}),{})}}else if(isSet(val)){return{[`Set(${val.size})`]:[...val.values()]}}else if(isObject(val)&&!isArray(val)&&!isPlainObject(val)){return String(val)}return val};const EMPTY_OBJ={};const EMPTY_ARR=[];const NOOP=()=>{};const NO=()=>false;const onRE=/^on[^a-z]/;const isOn=key=>onRE.test(key);const isModelListener=key=>key.startsWith("onUpdate:");const extend=Object.assign;const remove=(arr,el)=>{const i=arr.indexOf(el);if(i>-1){arr.splice(i,1)}};const hasOwnProperty=Object.prototype.hasOwnProperty;const hasOwn=(val,key)=>hasOwnProperty.call(val,key);const isArray=Array.isArray;const isMap=val=>toTypeString(val)==="[object Map]";const isSet=val=>toTypeString(val)==="[object Set]";const isFunction=val=>typeof val==="function";const isString=val=>typeof val==="string";const isSymbol=val=>typeof val==="symbol";const isObject=val=>val!==null&&typeof val==="object";const isPromise=val=>isObject(val)&&isFunction(val.then)&&isFunction(val.catch);const objectToString=Object.prototype.toString;const toTypeString=value=>objectToString.call(value);const toRawType=value=>toTypeString(value).slice(8,-1);const isPlainObject=val=>toTypeString(val)==="[object Object]";const isIntegerKey=key=>isString(key)&&key!=="NaN"&&key[0]!=="-"&&""+parseInt(key,10)===key;const isReservedProp=makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");const cacheStringFunction=fn=>{const cache=Object.create(null);return str=>{const hit=cache[str];return hit||(cache[str]=fn(str))}};const camelizeRE=/-(\w)/g;const camelize=cacheStringFunction((str=>str.replace(camelizeRE,((_,c)=>c?c.toUpperCase():""))));const hyphenateRE=/\B([A-Z])/g;const hyphenate=cacheStringFunction((str=>str.replace(hyphenateRE,"-$1").toLowerCase()));const capitalize=cacheStringFunction((str=>str.charAt(0).toUpperCase()+str.slice(1)));const toHandlerKey=cacheStringFunction((str=>str?`on${capitalize(str)}`:``));const hasChanged=(value,oldValue)=>!Object.is(value,oldValue);const invokeArrayFns$1=(fns,arg)=>{for(let i=0;i<fns.length;i++){fns[i](arg)}};const def=(obj,key,value)=>{Object.defineProperty(obj,key,{configurable:true,enumerable:false,value:value})};const toNumber=val=>{const n=parseFloat(val);return isNaN(n)?val:n};const SLOT_DEFAULT_NAME="d";const ON_SHOW="onShow";const ON_HIDE="onHide";const ON_LAUNCH="onLaunch";const ON_ERROR="onError";const ON_THEME_CHANGE="onThemeChange";const ON_PAGE_NOT_FOUND="onPageNotFound";const ON_UNHANDLE_REJECTION="onUnhandledRejection";const ON_LOAD="onLoad";const ON_READY="onReady";const ON_UNLOAD="onUnload";const ON_INIT="onInit";const ON_SAVE_EXIT_STATE="onSaveExitState";const ON_RESIZE="onResize";const ON_BACK_PRESS="onBackPress";const ON_PAGE_SCROLL="onPageScroll";const ON_TAB_ITEM_TAP="onTabItemTap";const ON_REACH_BOTTOM="onReachBottom";const ON_PULL_DOWN_REFRESH="onPullDownRefresh";const ON_SHARE_TIMELINE="onShareTimeline";const ON_ADD_TO_FAVORITES="onAddToFavorites";const ON_SHARE_APP_MESSAGE="onShareAppMessage";const ON_NAVIGATION_BAR_BUTTON_TAP="onNavigationBarButtonTap";const ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED="onNavigationBarSearchInputClicked";const ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED="onNavigationBarSearchInputChanged";const ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED="onNavigationBarSearchInputConfirmed";const ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED="onNavigationBarSearchInputFocusChanged";const customizeRE=/:/g;function customizeEvent(str){return camelize(str.replace(customizeRE,"-"))}function hasLeadingSlash(str){return str.indexOf("/")===0}function addLeadingSlash(str){return hasLeadingSlash(str)?str:"/"+str}const invokeArrayFns=(fns,arg)=>{let ret;for(let i=0;i<fns.length;i++){ret=fns[i](arg)}return ret};function getValueByDataPath(obj,path){if(!isString(path)){return}path=path.replace(/\[(\d+)\]/g,".$1");const parts=path.split(".");let key=parts[0];if(!obj){obj={}}if(parts.length===1){return obj[key]}return getValueByDataPath(obj[key],parts.slice(1).join("."))}const encode=encodeURIComponent;function stringifyQuery(obj,encodeStr=encode){const res=obj?Object.keys(obj).map((key=>{let val=obj[key];if(typeof val===void 0||val===null){val=""}else if(isPlainObject(val)){val=JSON.stringify(val)}return encodeStr(key)+"="+encodeStr(val)})).filter((x=>x.length>0)).join("&"):null;return res?`?${res}`:""}class EventChannel{constructor(id2,events){this.id=id2;this.listener={};this.emitCache={};if(events){Object.keys(events).forEach((name=>{this.on(name,events[name])}))}}emit(eventName,...args){const fns=this.listener[eventName];if(!fns){return(this.emitCache[eventName]||(this.emitCache[eventName]=[])).push(args)}fns.forEach((opt=>{opt.fn.apply(opt.fn,args)}));this.listener[eventName]=fns.filter((opt=>opt.type!=="once"))}on(eventName,fn){this._addListener(eventName,"on",fn);this._clearCache(eventName)}once(eventName,fn){this._addListener(eventName,"once",fn);this._clearCache(eventName)}off(eventName,fn){const fns=this.listener[eventName];if(!fns){return}if(fn){for(let i=0;i<fns.length;){if(fns[i].fn===fn){fns.splice(i,1);i--}i++}}else{delete this.listener[eventName]}}_clearCache(eventName){const cacheArgs=this.emitCache[eventName];if(cacheArgs){for(;cacheArgs.length>0;){this.emit.apply(this,[eventName,...cacheArgs.shift()])}}}_addListener(eventName,type,fn){(this.listener[eventName]||(this.listener[eventName]=[])).push({fn:fn,type:type})}}const PAGE_HOOKS=[ON_INIT,ON_LOAD,ON_SHOW,ON_HIDE,ON_UNLOAD,ON_BACK_PRESS,ON_PAGE_SCROLL,ON_TAB_ITEM_TAP,ON_REACH_BOTTOM,ON_PULL_DOWN_REFRESH,ON_SHARE_TIMELINE,ON_SHARE_APP_MESSAGE,ON_ADD_TO_FAVORITES,ON_SAVE_EXIT_STATE,ON_NAVIGATION_BAR_BUTTON_TAP,ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED,ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED,ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED,ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED];function isRootHook(name){return PAGE_HOOKS.indexOf(name)>-1}const UniLifecycleHooks=[ON_SHOW,ON_HIDE,ON_LAUNCH,ON_ERROR,ON_THEME_CHANGE,ON_PAGE_NOT_FOUND,ON_UNHANDLE_REJECTION,ON_INIT,ON_LOAD,ON_READY,ON_UNLOAD,ON_RESIZE,ON_BACK_PRESS,ON_PAGE_SCROLL,ON_TAB_ITEM_TAP,ON_REACH_BOTTOM,ON_PULL_DOWN_REFRESH,ON_SHARE_TIMELINE,ON_ADD_TO_FAVORITES,ON_SHARE_APP_MESSAGE,ON_SAVE_EXIT_STATE,ON_NAVIGATION_BAR_BUTTON_TAP,ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED,ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED,ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED,ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED];const MINI_PROGRAM_PAGE_RUNTIME_HOOKS=(()=>({onPageScroll:1,onShareAppMessage:1<<1,onShareTimeline:1<<2}))();let vueApp;const createVueAppHooks=[];function onCreateVueApp(hook){if(vueApp){return hook(vueApp)}createVueAppHooks.push(hook)}function invokeCreateVueAppHook(app){vueApp=app;createVueAppHooks.forEach((hook=>hook(app)))}const E=function(){};E.prototype={on:function(name,callback,ctx){var e=this.e||(this.e={});(e[name]||(e[name]=[])).push({fn:callback,ctx:ctx});return this},once:function(name,callback,ctx){var self=this;function listener(){self.off(name,listener);callback.apply(ctx,arguments)}listener._=callback;return this.on(name,listener,ctx)},emit:function(name){var data=[].slice.call(arguments,1);var evtArr=((this.e||(this.e={}))[name]||[]).slice();var i=0;var len=evtArr.length;for(i;i<len;i++){evtArr[i].fn.apply(evtArr[i].ctx,data)}return this},off:function(name,callback){var e=this.e||(this.e={});var evts=e[name];var liveEvents=[];if(evts&&callback){for(var i=0,len=evts.length;i<len;i++){if(evts[i].fn!==callback&&evts[i].fn._!==callback)liveEvents.push(evts[i])}}liveEvents.length?e[name]=liveEvents:delete e[name];return this}};var E$1=E;const eventChannels$1={};const eventChannelStack$1=[];let id=0;function initEventChannel(events,cache=true){id++;const eventChannel=new my.EventChannel(id,events);if(cache){eventChannels$1[id]=eventChannel;eventChannelStack$1.push(eventChannel)}return eventChannel}function getEventChannel$1(id2){if(id2){const eventChannel=eventChannels$1[id2];delete eventChannels$1[id2];return eventChannel}return eventChannelStack$1.shift()}const navigateTo={args(fromArgs){const id2=initEventChannel(fromArgs.events).id;if(fromArgs.url){fromArgs.url=fromArgs.url+(fromArgs.url.indexOf("?")===-1?"?":"&")+"__id__="+id2}},returnValue(fromRes){fromRes.eventChannel=getEventChannel$1()}};function getBaseSystemInfo(){return my.getSystemInfoSync()}function tryCatch(fn){return function(){try{return fn.apply(fn,arguments)}catch(e){console.error(e)}}}function getApiCallbacks(args){const apiCallbacks={};for(const name in args){const fn=args[name];if(isFunction(fn)){apiCallbacks[name]=tryCatch(fn);delete args[name]}}return apiCallbacks}const HOOK_SUCCESS="success";const HOOK_FAIL="fail";const HOOK_COMPLETE="complete";const globalInterceptors={};const scopedInterceptors={};function wrapperHook(hook){return function(data){return hook(data)||data}}function queue$1(hooks,data){let promise=false;for(let i=0;i<hooks.length;i++){const hook=hooks[i];if(promise){promise=Promise.resolve(wrapperHook(hook))}else{const res=hook(data);if(isPromise(res)){promise=Promise.resolve(res)}if(res===false){return{then(){},catch(){}}}}}return promise||{then(callback){return callback(data)},catch(){}}}function wrapperOptions(interceptors2,options={}){[HOOK_SUCCESS,HOOK_FAIL,HOOK_COMPLETE].forEach((name=>{const hooks=interceptors2[name];if(!isArray(hooks)){return}const oldCallback=options[name];options[name]=function callbackInterceptor(res){queue$1(hooks,res).then((res2=>isFunction(oldCallback)&&oldCallback(res2)||res2))}}));return options}function wrapperReturnValue(method,returnValue2){const returnValueHooks=[];if(isArray(globalInterceptors.returnValue)){returnValueHooks.push(...globalInterceptors.returnValue)}const interceptor=scopedInterceptors[method];if(interceptor&&isArray(interceptor.returnValue)){returnValueHooks.push(...interceptor.returnValue)}returnValueHooks.forEach((hook=>{returnValue2=hook(returnValue2)||returnValue2}));return returnValue2}function getApiInterceptorHooks(method){const interceptor=Object.create(null);Object.keys(globalInterceptors).forEach((hook=>{if(hook!=="returnValue"){interceptor[hook]=globalInterceptors[hook].slice()}}));const scopedInterceptor=scopedInterceptors[method];if(scopedInterceptor){Object.keys(scopedInterceptor).forEach((hook=>{if(hook!=="returnValue"){interceptor[hook]=(interceptor[hook]||[]).concat(scopedInterceptor[hook])}}))}return interceptor}function invokeApi(method,api,options,params){const interceptor=getApiInterceptorHooks(method);if(interceptor&&Object.keys(interceptor).length){if(isArray(interceptor.invoke)){const res=queue$1(interceptor.invoke,options);return res.then((options2=>api(wrapperOptions(interceptor,options2),...params)))}else{return api(wrapperOptions(interceptor,options),...params)}}return api(options,...params)}function handlePromise(promise){return promise}function formatApiArgs(args,options){const params=args[0];if(!options||!isPlainObject(options.formatArgs)&&isPlainObject(params)){return}const formatArgs=options.formatArgs;const keys=Object.keys(formatArgs);for(let i=0;i<keys.length;i++){const name=keys[i];const formatterOrDefaultValue=formatArgs[name];if(isFunction(formatterOrDefaultValue)){const errMsg=formatterOrDefaultValue(args[0][name],params);if(isString(errMsg)){return errMsg}}else{if(!hasOwn(params,name)){params[name]=formatterOrDefaultValue}}}}function beforeInvokeApi(name,args,protocol,options){if(options&&options.beforeInvoke){const errMsg2=options.beforeInvoke(args);if(isString(errMsg2)){return errMsg2}}const errMsg=formatApiArgs(args,options);if(errMsg){return errMsg}}function wrapperSyncApi(name,fn,protocol,options){return(...args)=>{const errMsg=beforeInvokeApi(name,args,protocol,options);if(errMsg){throw new Error(errMsg)}return fn.apply(null,args)}}function defineSyncApi(name,fn,protocol,options){return wrapperSyncApi(name,fn,void 0,options)}const API_UPX2PX="upx2px";const EPS=1e-4;const BASE_DEVICE_WIDTH=750;let isIOS=false;let deviceWidth=0;let deviceDPR=0;function checkDeviceWidth(){const{platform:platform,pixelRatio:pixelRatio,windowWidth:windowWidth}=getBaseSystemInfo();deviceWidth=windowWidth;deviceDPR=pixelRatio;isIOS=platform==="ios"}const upx2px=defineSyncApi(API_UPX2PX,((number,newDeviceWidth)=>{if(deviceWidth===0){checkDeviceWidth()}number=Number(number);if(number===0){return 0}let width=newDeviceWidth||deviceWidth;let result=number/BASE_DEVICE_WIDTH*width;if(result<0){result=-result}result=Math.floor(result+EPS);if(result===0){if(deviceDPR===1||!isIOS){result=1}else{result=.5}}return number<0?-result:result}));const API_ADD_INTERCEPTOR="addInterceptor";const API_REMOVE_INTERCEPTOR="removeInterceptor";function mergeInterceptorHook(interceptors2,interceptor){Object.keys(interceptor).forEach((hook=>{if(isFunction(interceptor[hook])){interceptors2[hook]=mergeHook(interceptors2[hook],interceptor[hook])}}))}function removeInterceptorHook(interceptors2,interceptor){if(!interceptors2||!interceptor){return}Object.keys(interceptor).forEach((name=>{const hooks=interceptors2[name];const hook=interceptor[name];if(isArray(hooks)&&isFunction(hook)){remove(hooks,hook)}}))}function mergeHook(parentVal,childVal){const res=childVal?parentVal?parentVal.concat(childVal):isArray(childVal)?childVal:[childVal]:parentVal;return res?dedupeHooks(res):res}function dedupeHooks(hooks){const res=[];for(let i=0;i<hooks.length;i++){if(res.indexOf(hooks[i])===-1){res.push(hooks[i])}}return res}const addInterceptor=defineSyncApi(API_ADD_INTERCEPTOR,((method,interceptor)=>{if(typeof method==="string"&&isPlainObject(interceptor)){mergeInterceptorHook(scopedInterceptors[method]||(scopedInterceptors[method]={}),interceptor)}else if(isPlainObject(method)){mergeInterceptorHook(globalInterceptors,method)}}));const removeInterceptor=defineSyncApi(API_REMOVE_INTERCEPTOR,((method,interceptor)=>{if(typeof method==="string"){if(isPlainObject(interceptor)){removeInterceptorHook(scopedInterceptors[method],interceptor)}else{delete scopedInterceptors[method]}}else if(isPlainObject(method)){removeInterceptorHook(globalInterceptors,method)}}));const interceptors={};const API_ON="$on";const API_ONCE="$once";const API_OFF="$off";const API_EMIT="$emit";const emitter=new E$1;const $on=defineSyncApi(API_ON,((name,callback)=>{emitter.on(name,callback);return()=>emitter.off(name,callback)}));const $once=defineSyncApi(API_ONCE,((name,callback)=>{emitter.once(name,callback);return()=>emitter.off(name,callback)}));const $off=defineSyncApi(API_OFF,((name,callback)=>{if(!name){emitter.e={};return}if(!Array.isArray(name))name=[name];name.forEach((n=>emitter.off(n,callback)))}));const $emit=defineSyncApi(API_EMIT,((name,...args)=>{emitter.emit(name,...args)}));let cid;let cidErrMsg;function normalizePushMessage(message){try{return JSON.parse(message)}catch(e){}return message}function invokePushCallback(args){if(args.type==="clientId"){cid=args.cid;cidErrMsg=args.errMsg;invokeGetPushCidCallbacks(cid,args.errMsg)}else if(args.type==="pushMsg"){onPushMessageCallbacks.forEach((callback=>{callback({type:"receive",data:normalizePushMessage(args.message)})}))}else if(args.type==="click"){onPushMessageCallbacks.forEach((callback=>{callback({type:"click",data:normalizePushMessage(args.message)})}))}}const getPushCidCallbacks=[];function invokeGetPushCidCallbacks(cid2,errMsg){getPushCidCallbacks.forEach((callback=>{callback(cid2,errMsg)}));getPushCidCallbacks.length=0}function getPushCid(args){if(!isPlainObject(args)){args={}}const{success:success,fail:fail,complete:complete}=getApiCallbacks(args);const hasSuccess=isFunction(success);const hasFail=isFunction(fail);const hasComplete=isFunction(complete);getPushCidCallbacks.push(((cid2,errMsg)=>{let res;if(cid2){res={errMsg:"getPushCid:ok",cid:cid2};hasSuccess&&success(res)}else{res={errMsg:"getPushCid:fail"+(errMsg?" "+errMsg:"")};hasFail&&fail(res)}hasComplete&&complete(res)}));if(typeof cid!=="undefined"){Promise.resolve().then((()=>invokeGetPushCidCallbacks(cid,cidErrMsg)))}}const onPushMessageCallbacks=[];const onPushMessage=fn=>{if(onPushMessageCallbacks.indexOf(fn)===-1){onPushMessageCallbacks.push(fn)}};const offPushMessage=fn=>{if(!fn){onPushMessageCallbacks.length=0}else{const index2=onPushMessageCallbacks.indexOf(fn);if(index2>-1){onPushMessageCallbacks.splice(index2,1)}}};const SYNC_API_RE=/^\$|getLocale|setLocale|sendNativeEvent|restoreGlobal|requireGlobal|getCurrentSubNVue|getMenuButtonBoundingClientRect|^report|interceptors|Interceptor$|getSubNVueById|requireNativePlugin|upx2px|hideKeyboard|canIUse|^create|Sync$|Manager$|base64ToArrayBuffer|arrayBufferToBase64/;const CONTEXT_API_RE=/^create|Manager$/;const CONTEXT_API_RE_EXC=["createBLEConnection"];const ASYNC_API=["createBLEConnection"];const CALLBACK_API_RE=/^on|^off/;function isContextApi(name){return CONTEXT_API_RE.test(name)&&CONTEXT_API_RE_EXC.indexOf(name)===-1}function isSyncApi(name){return SYNC_API_RE.test(name)&&ASYNC_API.indexOf(name)===-1}function isCallbackApi(name){return CALLBACK_API_RE.test(name)&&name!=="onPush"}function shouldPromise(name){if(isContextApi(name)||isSyncApi(name)||isCallbackApi(name)){return false}return true}if(!Promise.prototype.finally){Promise.prototype.finally=function(onfinally){const promise=this.constructor;return this.then((value=>promise.resolve(onfinally&&onfinally()).then((()=>value))),(reason=>promise.resolve(onfinally&&onfinally()).then((()=>{throw reason}))))}}function promisify(name,api){if(!shouldPromise(name)){return api}if(!isFunction(api)){return api}return function promiseApi(options={},...rest){if(isFunction(options.success)||isFunction(options.fail)||isFunction(options.complete)){return wrapperReturnValue(name,invokeApi(name,api,options,rest))}return wrapperReturnValue(name,handlePromise(new Promise(((resolve,reject)=>{invokeApi(name,api,extend({},options,{success:resolve,fail:reject}),rest)}))))}}const CALLBACKS=["success","fail","cancel","complete"];function initWrapper(protocols2){function processCallback(methodName,method,returnValue2){return function(res){return method(processReturnValue(methodName,res,returnValue2))}}function processArgs(methodName,fromArgs,argsOption={},returnValue2={},keepFromArgs=false){if(isPlainObject(fromArgs)){const toArgs=keepFromArgs===true?fromArgs:{};if(isFunction(argsOption)){argsOption=argsOption(fromArgs,toArgs)||{}}for(const key in fromArgs){if(hasOwn(argsOption,key)){let keyOption=argsOption[key];if(isFunction(keyOption)){keyOption=keyOption(fromArgs[key],fromArgs,toArgs)}if(!keyOption){console.warn(`支付宝小程序 ${methodName} 暂不支持 ${key}`)}else if(isString(keyOption)){toArgs[keyOption]=fromArgs[key]}else if(isPlainObject(keyOption)){toArgs[keyOption.name?keyOption.name:key]=keyOption.value}}else if(CALLBACKS.indexOf(key)!==-1){const callback=fromArgs[key];if(isFunction(callback)){toArgs[key]=processCallback(methodName,callback,returnValue2)}}else{if(!keepFromArgs&&!hasOwn(toArgs,key)){toArgs[key]=fromArgs[key]}}}return toArgs}else if(isFunction(fromArgs)){fromArgs=processCallback(methodName,fromArgs,returnValue2)}return fromArgs}function processReturnValue(methodName,res,returnValue2,keepReturnValue=false){if(isFunction(protocols2.returnValue)){res=protocols2.returnValue(methodName,res)}return processArgs(methodName,res,returnValue2,{},keepReturnValue)}return function wrapper(methodName,method){if(!hasOwn(protocols2,methodName)){return method}const protocol=protocols2[methodName];if(!protocol){return function(){console.error(`支付宝小程序 暂不支持${methodName}`)}}return function(arg1,arg2){let options=protocol;if(isFunction(protocol)){options=protocol(arg1)}arg1=processArgs(methodName,arg1,options.args,options.returnValue);const args=[arg1];if(typeof arg2!=="undefined"){args.push(arg2)}const returnValue2=my[options.name||methodName].apply(my,args);if(isSyncApi(methodName)){return processReturnValue(methodName,returnValue2,options.returnValue,isContextApi(methodName))}return returnValue2}}}const getLocale=()=>{const app=getApp({allowDefault:true});if(app&&app.$vm){return app.$vm.$locale}return my.getSystemInfoSync().language||"zh-Hans"};const setLocale=locale=>{const app=getApp();if(!app){return false}const oldLocale=app.$vm.$locale;if(oldLocale!==locale){app.$vm.$locale=locale;onLocaleChangeCallbacks.forEach((fn=>fn({locale:locale})));return true}return false};const onLocaleChangeCallbacks=[];const onLocaleChange=fn=>{if(onLocaleChangeCallbacks.indexOf(fn)===-1){onLocaleChangeCallbacks.push(fn)}};if(typeof global!=="undefined"){global.getLocale=getLocale}const baseApis={$on:$on,$off:$off,$once:$once,$emit:$emit,upx2px:upx2px,interceptors:interceptors,addInterceptor:addInterceptor,removeInterceptor:removeInterceptor,onCreateVueApp:onCreateVueApp,invokeCreateVueAppHook:invokeCreateVueAppHook,getLocale:getLocale,setLocale:setLocale,onLocaleChange:onLocaleChange,getPushCid:getPushCid,onPushMessage:onPushMessage,offPushMessage:offPushMessage,invokePushCallback:invokePushCallback};function initUni(api,protocols2){const wrapper=initWrapper(protocols2);const UniProxyHandlers={get(target,key){if(hasOwn(target,key)){return target[key]}if(hasOwn(api,key)){return promisify(key,api[key])}if(hasOwn(baseApis,key)){return promisify(key,baseApis[key])}return promisify(key,wrapper(key,my[key]))}};return new Proxy({},UniProxyHandlers)}function initGetProvider(providers){return function getProvider2({service:service,success:success,fail:fail,complete:complete}){let res;if(providers[service]){res={errMsg:"getProvider:ok",service:service,provider:providers[service]};isFunction(success)&&success(res)}else{res={errMsg:"getProvider:fail:服务["+service+"]不存在"};isFunction(fail)&&fail(res)}isFunction(complete)&&complete(res)}}function addSafeAreaInsets(fromRes,toRes){if(fromRes.safeArea){const safeArea=fromRes.safeArea;toRes.safeAreaInsets={top:safeArea.top,left:safeArea.left,right:fromRes.windowWidth-safeArea.right,bottom:fromRes.windowHeight-safeArea.bottom}}}const UUID_KEY="__DC_STAT_UUID";let deviceId;function useDeviceId(global2=my){return function addDeviceId(_,toRes){deviceId=deviceId||global2.getStorageSync(UUID_KEY);if(!deviceId){deviceId=Date.now()+""+Math.floor(Math.random()*1e7);my.setStorage({key:UUID_KEY,data:deviceId})}toRes.deviceId=deviceId}}const redirectTo={};const getProvider=initGetProvider({oauth:["alipay"],share:["alipay"],payment:["alipay"],push:["alipay"]});function setStorageSync(key,data){return my.setStorageSync({key:key,data:data})}function getStorageSync(key){const result=my.getStorageSync({key:key});return result.data!==null?result.data:""}function removeStorageSync(key){return my.removeStorageSync({key:key})}function startGyroscope(args){if(hasOwn(args,"interval")){console.warn("支付宝小程序 startGyroscope暂不支持interval")}args.success&&args.success({errMsg:"startGyroscope:ok"});args.complete&&args.complete({errMsg:"startGyroscope:ok"})}function createExecCallback(execCallback){return function wrapperExecCallback(res){this.actions.forEach(((action,index2)=>{(action._$callbacks||[]).forEach((callback=>{callback(res[index2])}))}));if(isFunction(execCallback)){execCallback(res)}}}function addCallback(callback){if(isFunction(callback)){const action=this.actions[this.actions.length-1];if(action){(action._$callbacks||(action._$callbacks=[])).push(callback)}}}function createSelectorQuery(){const query=my.createSelectorQuery();const oldExec=query.exec;const oldScrollOffset=query.scrollOffset;const oldBoundingClientRect=query.boundingClientRect;query.exec=function exec(callback){return oldExec.call(this,createExecCallback(callback).bind(this))};query.scrollOffset=function scrollOffset(callback){const ret=oldScrollOffset.call(this);addCallback.call(this,callback);return ret};query.boundingClientRect=function boundingClientRect(callback){const ret=oldBoundingClientRect.call(this);addCallback.call(this,callback);return ret};if(!query.fields){query.fields=function({rect:rect,size:size2,scrollOffset:scrollOffset},callback){if(rect||size2){this.boundingClientRect()}if(scrollOffset){this.scrollOffset()}addCallback.call(this,callback);return this}}if(!query.in){query.in=function(){return this}}return query}function createIntersectionObserver(component,options){if(options&&options.observeAll){options.selectAll=options.observeAll;delete options.observeAll}return my.createIntersectionObserver(options)}var shims=Object.freeze({__proto__:null,getProvider:getProvider,setStorageSync:setStorageSync,getStorageSync:getStorageSync,removeStorageSync:removeStorageSync,startGyroscope:startGyroscope,createSelectorQuery:createSelectorQuery,createIntersectionObserver:createIntersectionObserver});function handleNetworkInfo(fromRes,toRes){const nextworkType=fromRes.networkType;switch(nextworkType){case"NOTREACHABLE":toRes.networkType="none";break;case"WWAN":toRes.networkType="3g";break;default:toRes.networkType=fromRes.networkType.toLowerCase();break}}function handleSystemInfo(fromRes,toRes){addSafeAreaInsets(fromRes,toRes);useDeviceId({getStorageSync:getStorageSync})(fromRes,toRes);let platform=fromRes.platform?fromRes.platform.toLowerCase():"devtools";if(!~["android","ios"].indexOf(platform)){platform="devtools"}toRes.platform=platform}function returnValue(methodName,res={}){if(res.error||res.errorMessage){res.errMsg=`${methodName}:fail ${res.errorMessage||res.error}`;delete res.error;delete res.errorMessage}else{res.errMsg=`${methodName}:ok`}return res}const request={name:my.canIUse("request")?"request":"httpRequest",args(fromArgs){const method=fromArgs.method||"GET";if(!fromArgs.header){fromArgs.header={}}const headers={"content-type":"application/json"};Object.keys(fromArgs.header).forEach((key=>{headers[key.toLocaleLowerCase()]=fromArgs.header[key]}));return{header(){return{name:"headers",value:headers}},data(data){if(my.canIUse("saveFileToDingTalk")&&method.toUpperCase()==="POST"&&headers["content-type"].indexOf("application/json")===0&&isPlainObject(data)){return{name:"data",value:JSON.stringify(data)}}return{name:"data",value:data}},method:"method",responseType:false}},returnValue:{status:"statusCode",headers:"header"}};const setNavigationBarColor={name:"setNavigationBar",args:{frontColor:false,animation:false}};const setNavigationBarTitle={name:"setNavigationBar"};function showModal({showCancel:showCancel=true}={}){if(showCancel){return{name:"confirm",args:{cancelColor:false,confirmColor:false,cancelText:"cancelButtonText",confirmText:"confirmButtonText"},returnValue(fromRes,toRes){toRes.confirm=fromRes.confirm;toRes.cancel=!fromRes.confirm}}}return{name:"alert",args:{confirmColor:false,confirmText:"buttonText"},returnValue(fromRes,toRes){toRes.confirm=true;toRes.cancel=false}}}function showToast({icon:icon="success"}={}){const args={title:"content",icon:"type",duration:false,image:false,mask:false};if(icon==="loading"){return{name:"showLoading",args:args}}return{name:"showToast",args:args}}const showActionSheet={name:"showActionSheet",args:{itemList:"items",itemColor:false},returnValue:{index:"tapIndex"}};const showLoading={args:{title:"content",mask:false}};const uploadFile={args:{name:"fileName"}};const downloadFile={returnValue:{apFilePath:"tempFilePath"}};const getFileInfo={args:{filePath:"apFilePath"}};const compressImage={args(fromArgs,toArgs){toArgs.compressLevel=4;if(fromArgs&&fromArgs.quality){toArgs.compressLevel=Math.floor(fromArgs.quality/26)}if(fromArgs.src){toArgs.apFilePaths=[fromArgs.src]}},returnValue(fromRes,toRes){const apFilePaths=fromRes.apFilePaths;if(apFilePaths&&apFilePaths.length){toRes.tempFilePath=apFilePaths[0]}}};const chooseVideo={returnValue:{apFilePath:"tempFilePath"}};const connectSocket={args:{method:false,protocols:false}};const chooseImage={returnValue(result){var _a,_b;const hasTempFilePaths=hasOwn(result,"tempFilePaths")&&result.tempFilePaths;if(hasOwn(result,"apFilePaths")&&!hasTempFilePaths){result.tempFilePaths=[];(_a=result.apFilePaths)===null||_a===void 0?void 0:_a.forEach((apFilePath=>{var _a2;return(_a2=result.tempFilePaths)===null||_a2===void 0?void 0:_a2.push(apFilePath)}))}if(!hasOwn(result,"tempFiles")&&hasTempFilePaths){result.tempFiles=[];(_b=result.tempFilePaths)===null||_b===void 0?void 0:_b.forEach((tempFilePath=>{var _a2;return(_a2=result.tempFiles)===null||_a2===void 0?void 0:_a2.push({path:tempFilePath})}))}return{}}};const previewImage={args(fromArgs,toArgs){const currentIndex=Number(fromArgs.current);if(isNaN(currentIndex)){if(fromArgs.current&&isArray(fromArgs.urls)){const index2=fromArgs.urls.indexOf(fromArgs.current);toArgs.current=~index2?index2:0}}else{toArgs.current=currentIndex}return{indicator:false,loop:false}}};const saveFile={args:{tempFilePath:"apFilePath"},returnValue:{apFilePath:"savedFilePath"}};const getSavedFileInfo={args:{filePath:"apFilePath"}};const getSavedFileList={returnValue(fromRes,toRes){toRes.fileList=fromRes.fileList.map((file=>({filePath:file.apFilePath,createTime:file.createTime,size:file.size})))}};const removeSavedFile={args:{filePath:"apFilePath"}};const getLocation={args:{type:false,altitude:false}};const openLocation={args:{}};const getNetworkType={returnValue:handleNetworkInfo};const onNetworkStatusChange={returnValue:handleNetworkInfo};const stopAccelerometer={name:"offAccelerometerChange"};const stopCompass={name:"offCompassChange"};const scanCode={name:"scan",args:{onlyFromCamera:"hideAlbum"},returnValue:{code:"result"}};const setClipboardData={name:"setClipboard",args:{data:"text"}};const getClipboardData={name:"getClipboard",returnValue:{text:"data"}};const pageScrollTo={args:{duration:false}};const login={name:"getAuthCode",returnValue:{authCode:"code"}};const getUserInfo={name:my.canIUse("getOpenUserInfo")?"getOpenUserInfo":"getAuthUserInfo",returnValue(fromRes,toRes){if(my.canIUse("getOpenUserInfo")){let response;try{response=JSON.parse(fromRes.response).response}catch(e){}if(response){toRes.userInfo=response;toRes.userInfo.avatarUrl=response.avatar;delete response.avatar}}else{toRes.userInfo={openId:"",nickName:fromRes.nickName,avatarUrl:fromRes.avatar}}}};const requestPayment={name:"tradePay",args:{orderInfo:"tradeNO"}};const getBLEDeviceServices={returnValue(fromRes,toRes){toRes.services=fromRes.services.map((item=>({uuid:item.serviceId,isPrimary:item.isPrimary})))}};const createBLEConnection={name:"connectBLEDevice",args:{timeout:false}};const closeBLEConnection={name:"disconnectBLEDevice"};const onBLEConnectionStateChange={name:"onBLEConnectionStateChanged"};const makePhoneCall={args:{phoneNumber:"number"}};const stopGyroscope={name:"offGyroscopeChange"};const getSystemInfo={returnValue:handleSystemInfo};const getSystemInfoSync={returnValue:handleSystemInfo};const canvasToTempFilePath={returnValue(fromRes,toRes){toRes.tempFilePath=fromRes.apFilePath}};const setScreenBrightness={args:{value:"brightness"}};const getScreenBrightness={returnValue:{brightness:"value"}};const showShareMenu={name:"showSharePanel"};const hideHomeButton={name:"hideBackHome"};const saveImageToPhotosAlbum={name:"saveImage",args:{filePath:"url"}};const saveVideoToPhotosAlbum={args:{filePath:"src"}};const chooseAddress={name:"getAddress",returnValue(fromRes,toRes){const info=fromRes.result||{};toRes.userName=info.fullname;toRes.countyName=info.country;toRes.provinceName=info.prov;toRes.cityName=info.city;toRes.detailInfo=info.address;toRes.telNumber=info.mobilePhone;toRes.errMsg=toRes.errMsg+" "+fromRes.resultStatus}};var protocols=Object.freeze({__proto__:null,returnValue:returnValue,request:request,setNavigationBarColor:setNavigationBarColor,setNavigationBarTitle:setNavigationBarTitle,showModal:showModal,showToast:showToast,showActionSheet:showActionSheet,showLoading:showLoading,uploadFile:uploadFile,downloadFile:downloadFile,getFileInfo:getFileInfo,compressImage:compressImage,chooseVideo:chooseVideo,connectSocket:connectSocket,chooseImage:chooseImage,previewImage:previewImage,saveFile:saveFile,getSavedFileInfo:getSavedFileInfo,getSavedFileList:getSavedFileList,removeSavedFile:removeSavedFile,getLocation:getLocation,openLocation:openLocation,getNetworkType:getNetworkType,onNetworkStatusChange:onNetworkStatusChange,stopAccelerometer:stopAccelerometer,stopCompass:stopCompass,scanCode:scanCode,setClipboardData:setClipboardData,getClipboardData:getClipboardData,pageScrollTo:pageScrollTo,login:login,getUserInfo:getUserInfo,requestPayment:requestPayment,getBLEDeviceServices:getBLEDeviceServices,createBLEConnection:createBLEConnection,closeBLEConnection:closeBLEConnection,onBLEConnectionStateChange:onBLEConnectionStateChange,makePhoneCall:makePhoneCall,stopGyroscope:stopGyroscope,getSystemInfo:getSystemInfo,getSystemInfoSync:getSystemInfoSync,canvasToTempFilePath:canvasToTempFilePath,setScreenBrightness:setScreenBrightness,getScreenBrightness:getScreenBrightness,showShareMenu:showShareMenu,hideHomeButton:hideHomeButton,saveImageToPhotosAlbum:saveImageToPhotosAlbum,saveVideoToPhotosAlbum:saveVideoToPhotosAlbum,chooseAddress:chooseAddress,redirectTo:redirectTo,navigateTo:navigateTo});var index=initUni(shims,protocols);let activeEffectScope;class EffectScope{constructor(detached=false){this.active=true;this.effects=[];this.cleanups=[];if(!detached&&activeEffectScope){this.parent=activeEffectScope;this.index=(activeEffectScope.scopes||(activeEffectScope.scopes=[])).push(this)-1}}run(fn){if(this.active){const currentEffectScope=activeEffectScope;try{activeEffectScope=this;return fn()}finally{activeEffectScope=currentEffectScope}}}on(){activeEffectScope=this}off(){activeEffectScope=this.parent}stop(fromParent){if(this.active){let i,l;for(i=0,l=this.effects.length;i<l;i++){this.effects[i].stop()}for(i=0,l=this.cleanups.length;i<l;i++){this.cleanups[i]()}if(this.scopes){for(i=0,l=this.scopes.length;i<l;i++){this.scopes[i].stop(true)}}if(this.parent&&!fromParent){const last=this.parent.scopes.pop();if(last&&last!==this){this.parent.scopes[this.index]=last;last.index=this.index}}this.active=false}}}function recordEffectScope(effect,scope=activeEffectScope){if(scope&&scope.active){scope.effects.push(effect)}}const createDep=effects=>{const dep=new Set(effects);dep.w=0;dep.n=0;return dep};const wasTracked=dep=>(dep.w&trackOpBit)>0;const newTracked=dep=>(dep.n&trackOpBit)>0;const initDepMarkers=({deps:deps})=>{if(deps.length){for(let i=0;i<deps.length;i++){deps[i].w|=trackOpBit}}};const finalizeDepMarkers=effect=>{const{deps:deps}=effect;if(deps.length){let ptr=0;for(let i=0;i<deps.length;i++){const dep=deps[i];if(wasTracked(dep)&&!newTracked(dep)){dep.delete(effect)}else{deps[ptr++]=dep}dep.w&=~trackOpBit;dep.n&=~trackOpBit}deps.length=ptr}};const targetMap=new WeakMap;let effectTrackDepth=0;let trackOpBit=1;const maxMarkerBits=30;let activeEffect;const ITERATE_KEY=Symbol("");const MAP_KEY_ITERATE_KEY=Symbol("");class ReactiveEffect{constructor(fn,scheduler=null,scope){this.fn=fn;this.scheduler=scheduler;this.active=true;this.deps=[];this.parent=void 0;recordEffectScope(this,scope)}run(){if(!this.active){return this.fn()}let parent=activeEffect;let lastShouldTrack=shouldTrack;while(parent){if(parent===this){return}parent=parent.parent}try{this.parent=activeEffect;activeEffect=this;shouldTrack=true;trackOpBit=1<<++effectTrackDepth;if(effectTrackDepth<=maxMarkerBits){initDepMarkers(this)}else{cleanupEffect(this)}return this.fn()}finally{if(effectTrackDepth<=maxMarkerBits){finalizeDepMarkers(this)}trackOpBit=1<<--effectTrackDepth;activeEffect=this.parent;shouldTrack=lastShouldTrack;this.parent=void 0;if(this.deferStop){this.stop()}}}stop(){if(activeEffect===this){this.deferStop=true}else if(this.active){cleanupEffect(this);if(this.onStop){this.onStop()}this.active=false}}}function cleanupEffect(effect){const{deps:deps}=effect;if(deps.length){for(let i=0;i<deps.length;i++){deps[i].delete(effect)}deps.length=0}}let shouldTrack=true;const trackStack=[];function pauseTracking(){trackStack.push(shouldTrack);shouldTrack=false}function resetTracking(){const last=trackStack.pop();shouldTrack=last===void 0?true:last}function track(target,type,key){if(shouldTrack&&activeEffect){let depsMap=targetMap.get(target);if(!depsMap){targetMap.set(target,depsMap=new Map)}let dep=depsMap.get(key);if(!dep){depsMap.set(key,dep=createDep())}trackEffects(dep)}}function trackEffects(dep,debuggerEventExtraInfo){let shouldTrack2=false;if(effectTrackDepth<=maxMarkerBits){if(!newTracked(dep)){dep.n|=trackOpBit;shouldTrack2=!wasTracked(dep)}}else{shouldTrack2=!dep.has(activeEffect)}if(shouldTrack2){dep.add(activeEffect);activeEffect.deps.push(dep)}}function trigger(target,type,key,newValue,oldValue,oldTarget){const depsMap=targetMap.get(target);if(!depsMap){return}let deps=[];if(type==="clear"){deps=[...depsMap.values()]}else if(key==="length"&&isArray(target)){depsMap.forEach(((dep,key2)=>{if(key2==="length"||key2>=newValue){deps.push(dep)}}))}else{if(key!==void 0){deps.push(depsMap.get(key))}switch(type){case"add":if(!isArray(target)){deps.push(depsMap.get(ITERATE_KEY));if(isMap(target)){deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))}}else if(isIntegerKey(key)){deps.push(depsMap.get("length"))}break;case"delete":if(!isArray(target)){deps.push(depsMap.get(ITERATE_KEY));if(isMap(target)){deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))}}break;case"set":if(isMap(target)){deps.push(depsMap.get(ITERATE_KEY))}break}}if(deps.length===1){if(deps[0]){{triggerEffects(deps[0])}}}else{const effects=[];for(const dep of deps){if(dep){effects.push(...dep)}}{triggerEffects(createDep(effects))}}}function triggerEffects(dep,debuggerEventExtraInfo){for(const effect of isArray(dep)?dep:[...dep]){if(effect!==activeEffect||effect.allowRecurse){if(effect.scheduler){effect.scheduler()}else{effect.run()}}}}const isNonTrackableKeys=makeMap(`__proto__,__v_isRef,__isVue`);const builtInSymbols=new Set(Object.getOwnPropertyNames(Symbol).map((key=>Symbol[key])).filter(isSymbol));const get=createGetter();const shallowGet=createGetter(false,true);const readonlyGet=createGetter(true);const arrayInstrumentations=createArrayInstrumentations();function createArrayInstrumentations(){const instrumentations={};["includes","indexOf","lastIndexOf"].forEach((key=>{instrumentations[key]=function(...args){const arr=toRaw(this);for(let i=0,l=this.length;i<l;i++){track(arr,"get",i+"")}const res=arr[key](...args);if(res===-1||res===false){return arr[key](...args.map(toRaw))}else{return res}}}));["push","pop","shift","unshift","splice"].forEach((key=>{instrumentations[key]=function(...args){pauseTracking();const res=toRaw(this)[key].apply(this,args);resetTracking();return res}}));return instrumentations}function createGetter(isReadonly2=false,shallow=false){return function get2(target,key,receiver){if(key==="__v_isReactive"){return!isReadonly2}else if(key==="__v_isReadonly"){return isReadonly2}else if(key==="__v_isShallow"){return shallow}else if(key==="__v_raw"&&receiver===(isReadonly2?shallow?shallowReadonlyMap:readonlyMap:shallow?shallowReactiveMap:reactiveMap).get(target)){return target}const targetIsArray=isArray(target);if(!isReadonly2&&targetIsArray&&hasOwn(arrayInstrumentations,key)){return Reflect.get(arrayInstrumentations,key,receiver)}const res=Reflect.get(target,key,receiver);if(isSymbol(key)?builtInSymbols.has(key):isNonTrackableKeys(key)){return res}if(!isReadonly2){track(target,"get",key)}if(shallow){return res}if(isRef(res)){const shouldUnwrap=!targetIsArray||!isIntegerKey(key);return shouldUnwrap?res.value:res}if(isObject(res)){return isReadonly2?readonly(res):reactive(res)}return res}}const set$1=createSetter();const shallowSet=createSetter(true);function createSetter(shallow=false){return function set2(target,key,value,receiver){let oldValue=target[key];if(isReadonly(oldValue)&&isRef(oldValue)&&!isRef(value)){return false}if(!shallow&&!isReadonly(value)){if(!isShallow(value)){value=toRaw(value);oldValue=toRaw(oldValue)}if(!isArray(target)&&isRef(oldValue)&&!isRef(value)){oldValue.value=value;return true}}const hadKey=isArray(target)&&isIntegerKey(key)?Number(key)<target.length:hasOwn(target,key);const result=Reflect.set(target,key,value,receiver);if(target===toRaw(receiver)){if(!hadKey){trigger(target,"add",key,value)}else if(hasChanged(value,oldValue)){trigger(target,"set",key,value)}}return result}}function deleteProperty(target,key){const hadKey=hasOwn(target,key);target[key];const result=Reflect.deleteProperty(target,key);if(result&&hadKey){trigger(target,"delete",key,void 0)}return result}function has(target,key){const result=Reflect.has(target,key);if(!isSymbol(key)||!builtInSymbols.has(key)){track(target,"has",key)}return result}function ownKeys(target){track(target,"iterate",isArray(target)?"length":ITERATE_KEY);return Reflect.ownKeys(target)}const mutableHandlers={get:get,set:set$1,deleteProperty:deleteProperty,has:has,ownKeys:ownKeys};const readonlyHandlers={get:readonlyGet,set(target,key){return true},deleteProperty(target,key){return true}};const shallowReactiveHandlers=extend({},mutableHandlers,{get:shallowGet,set:shallowSet});const toShallow=value=>value;const getProto=v=>Reflect.getPrototypeOf(v);function get$1(target,key,isReadonly2=false,isShallow2=false){target=target["__v_raw"];const rawTarget=toRaw(target);const rawKey=toRaw(key);if(key!==rawKey){!isReadonly2&&track(rawTarget,"get",key)}!isReadonly2&&track(rawTarget,"get",rawKey);const{has:has2}=getProto(rawTarget);const wrap=isShallow2?toShallow:isReadonly2?toReadonly:toReactive;if(has2.call(rawTarget,key)){return wrap(target.get(key))}else if(has2.call(rawTarget,rawKey)){return wrap(target.get(rawKey))}else if(target!==rawTarget){target.get(key)}}function has$1(key,isReadonly2=false){const target=this["__v_raw"];const rawTarget=toRaw(target);const rawKey=toRaw(key);if(key!==rawKey){!isReadonly2&&track(rawTarget,"has",key)}!isReadonly2&&track(rawTarget,"has",rawKey);return key===rawKey?target.has(key):target.has(key)||target.has(rawKey)}function size(target,isReadonly2=false){target=target["__v_raw"];!isReadonly2&&track(toRaw(target),"iterate",ITERATE_KEY);return Reflect.get(target,"size",target)}function add(value){value=toRaw(value);const target=toRaw(this);const proto=getProto(target);const hadKey=proto.has.call(target,value);if(!hadKey){target.add(value);trigger(target,"add",value,value)}return this}function set$1$1(key,value){value=toRaw(value);const target=toRaw(this);const{has:has2,get:get2}=getProto(target);let hadKey=has2.call(target,key);if(!hadKey){key=toRaw(key);hadKey=has2.call(target,key)}const oldValue=get2.call(target,key);target.set(key,value);if(!hadKey){trigger(target,"add",key,value)}else if(hasChanged(value,oldValue)){trigger(target,"set",key,value)}return this}function deleteEntry(key){const target=toRaw(this);const{has:has2,get:get2}=getProto(target);let hadKey=has2.call(target,key);if(!hadKey){key=toRaw(key);hadKey=has2.call(target,key)}get2?get2.call(target,key):void 0;const result=target.delete(key);if(hadKey){trigger(target,"delete",key,void 0)}return result}function clear(){const target=toRaw(this);const hadItems=target.size!==0;const result=target.clear();if(hadItems){trigger(target,"clear",void 0,void 0)}return result}function createForEach(isReadonly2,isShallow2){return function forEach(callback,thisArg){const observed=this;const target=observed["__v_raw"];const rawTarget=toRaw(target);const wrap=isShallow2?toShallow:isReadonly2?toReadonly:toReactive;!isReadonly2&&track(rawTarget,"iterate",ITERATE_KEY);return target.forEach(((value,key)=>callback.call(thisArg,wrap(value),wrap(key),observed)))}}function createIterableMethod(method,isReadonly2,isShallow2){return function(...args){const target=this["__v_raw"];const rawTarget=toRaw(target);const targetIsMap=isMap(rawTarget);const isPair=method==="entries"||method===Symbol.iterator&&targetIsMap;const isKeyOnly=method==="keys"&&targetIsMap;const innerIterator=target[method](...args);const wrap=isShallow2?toShallow:isReadonly2?toReadonly:toReactive;!isReadonly2&&track(rawTarget,"iterate",isKeyOnly?MAP_KEY_ITERATE_KEY:ITERATE_KEY);return{next(){const{value:value,done:done}=innerIterator.next();return done?{value:value,done:done}:{value:isPair?[wrap(value[0]),wrap(value[1])]:wrap(value),done:done}},[Symbol.iterator](){return this}}}}function createReadonlyMethod(type){return function(...args){return type==="delete"?false:this}}function createInstrumentations(){const mutableInstrumentations2={get(key){return get$1(this,key)},get size(){return size(this)},has:has$1,add:add,set:set$1$1,delete:deleteEntry,clear:clear,forEach:createForEach(false,false)};const shallowInstrumentations2={get(key){return get$1(this,key,false,true)},get size(){return size(this)},has:has$1,add:add,set:set$1$1,delete:deleteEntry,clear:clear,forEach:createForEach(false,true)};const readonlyInstrumentations2={get(key){return get$1(this,key,true)},get size(){return size(this,true)},has(key){return has$1.call(this,key,true)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(true,false)};const shallowReadonlyInstrumentations2={get(key){return get$1(this,key,true,true)},get size(){return size(this,true)},has(key){return has$1.call(this,key,true)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(true,true)};const iteratorMethods=["keys","values","entries",Symbol.iterator];iteratorMethods.forEach((method=>{mutableInstrumentations2[method]=createIterableMethod(method,false,false);readonlyInstrumentations2[method]=createIterableMethod(method,true,false);shallowInstrumentations2[method]=createIterableMethod(method,false,true);shallowReadonlyInstrumentations2[method]=createIterableMethod(method,true,true)}));return[mutableInstrumentations2,readonlyInstrumentations2,shallowInstrumentations2,shallowReadonlyInstrumentations2]}const[mutableInstrumentations,readonlyInstrumentations,shallowInstrumentations,shallowReadonlyInstrumentations]=createInstrumentations();function createInstrumentationGetter(isReadonly2,shallow){const instrumentations=shallow?isReadonly2?shallowReadonlyInstrumentations:shallowInstrumentations:isReadonly2?readonlyInstrumentations:mutableInstrumentations;return(target,key,receiver)=>{if(key==="__v_isReactive"){return!isReadonly2}else if(key==="__v_isReadonly"){return isReadonly2}else if(key==="__v_raw"){return target}return Reflect.get(hasOwn(instrumentations,key)&&key in target?instrumentations:target,key,receiver)}}const mutableCollectionHandlers={get:createInstrumentationGetter(false,false)};const shallowCollectionHandlers={get:createInstrumentationGetter(false,true)};const readonlyCollectionHandlers={get:createInstrumentationGetter(true,false)};const reactiveMap=new WeakMap;const shallowReactiveMap=new WeakMap;const readonlyMap=new WeakMap;const shallowReadonlyMap=new WeakMap;function targetTypeMap(rawType){switch(rawType){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function getTargetType(value){return value["__v_skip"]||!Object.isExtensible(value)?0:targetTypeMap(toRawType(value))}function reactive(target){if(isReadonly(target)){return target}return createReactiveObject(target,false,mutableHandlers,mutableCollectionHandlers,reactiveMap)}function shallowReactive(target){return createReactiveObject(target,false,shallowReactiveHandlers,shallowCollectionHandlers,shallowReactiveMap)}function readonly(target){return createReactiveObject(target,true,readonlyHandlers,readonlyCollectionHandlers,readonlyMap)}function createReactiveObject(target,isReadonly2,baseHandlers,collectionHandlers,proxyMap){if(!isObject(target)){return target}if(target["__v_raw"]&&!(isReadonly2&&target["__v_isReactive"])){return target}const existingProxy=proxyMap.get(target);if(existingProxy){return existingProxy}const targetType=getTargetType(target);if(targetType===0){return target}const proxy=new Proxy(target,targetType===2?collectionHandlers:baseHandlers);proxyMap.set(target,proxy);return proxy}function isReactive(value){if(isReadonly(value)){return isReactive(value["__v_raw"])}return!!(value&&value["__v_isReactive"])}function isReadonly(value){return!!(value&&value["__v_isReadonly"])}function isShallow(value){return!!(value&&value["__v_isShallow"])}function toRaw(observed){const raw=observed&&observed["__v_raw"];return raw?toRaw(raw):observed}function markRaw(value){def(value,"__v_skip",true);return value}const toReactive=value=>isObject(value)?reactive(value):value;const toReadonly=value=>isObject(value)?readonly(value):value;function trackRefValue(ref2){if(shouldTrack&&activeEffect){ref2=toRaw(ref2);{trackEffects(ref2.dep||(ref2.dep=createDep()))}}}function triggerRefValue(ref2,newVal){ref2=toRaw(ref2);if(ref2.dep){{triggerEffects(ref2.dep)}}}function isRef(r){return!!(r&&r.__v_isRef===true)}function ref(value){return createRef(value,false)}function createRef(rawValue,shallow){if(isRef(rawValue)){return rawValue}return new RefImpl(rawValue,shallow)}class RefImpl{constructor(value,__v_isShallow){this.__v_isShallow=__v_isShallow;this.dep=void 0;this.__v_isRef=true;this._rawValue=__v_isShallow?value:toRaw(value);this._value=__v_isShallow?value:toReactive(value)}get value(){trackRefValue(this);return this._value}set value(newVal){newVal=this.__v_isShallow?newVal:toRaw(newVal);if(hasChanged(newVal,this._rawValue)){this._rawValue=newVal;this._value=this.__v_isShallow?newVal:toReactive(newVal);triggerRefValue(this)}}}function unref(ref2){return isRef(ref2)?ref2.value:ref2}const shallowUnwrapHandlers={get:(target,key,receiver)=>unref(Reflect.get(target,key,receiver)),set:(target,key,value,receiver)=>{const oldValue=target[key];if(isRef(oldValue)&&!isRef(value)){oldValue.value=value;return true}else{return Reflect.set(target,key,value,receiver)}}};function proxyRefs(objectWithRefs){return isReactive(objectWithRefs)?objectWithRefs:new Proxy(objectWithRefs,shallowUnwrapHandlers)}class ComputedRefImpl{constructor(getter,_setter,isReadonly2,isSSR){this._setter=_setter;this.dep=void 0;this.__v_isRef=true;this._dirty=true;this.effect=new ReactiveEffect(getter,(()=>{if(!this._dirty){this._dirty=true;triggerRefValue(this)}}));this.effect.computed=this;this.effect.active=this._cacheable=!isSSR;this["__v_isReadonly"]=isReadonly2}get value(){const self=toRaw(this);trackRefValue(self);if(self._dirty||!self._cacheable){self._dirty=false;self._value=self.effect.run()}return self._value}set value(newValue){this._setter(newValue)}}function computed(getterOrOptions,debugOptions,isSSR=false){let getter;let setter;const onlyGetter=isFunction(getterOrOptions);if(onlyGetter){getter=getterOrOptions;setter=NOOP}else{getter=getterOrOptions.get;setter=getterOrOptions.set}const cRef=new ComputedRefImpl(getter,setter,onlyGetter||!setter,isSSR);return cRef}const stack=[];function warn$1(msg,...args){pauseTracking();const instance=stack.length?stack[stack.length-1].component:null;const appWarnHandler=instance&&instance.appContext.config.warnHandler;const trace=getComponentTrace();if(appWarnHandler){callWithErrorHandling(appWarnHandler,instance,11,[msg+args.join(""),instance&&instance.proxy,trace.map((({vnode:vnode})=>`at <${formatComponentName(instance,vnode.type)}>`)).join("\n"),trace])}else{const warnArgs=[`[Vue warn]: ${msg}`,...args];if(trace.length&&true){warnArgs.push(`\n`,...formatTrace(trace))}console.warn(...warnArgs)}resetTracking()}function getComponentTrace(){let currentVNode=stack[stack.length-1];if(!currentVNode){return[]}const normalizedStack=[];while(currentVNode){const last=normalizedStack[0];if(last&&last.vnode===currentVNode){last.recurseCount++}else{normalizedStack.push({vnode:currentVNode,recurseCount:0})}const parentInstance=currentVNode.component&&currentVNode.component.parent;currentVNode=parentInstance&&parentInstance.vnode}return normalizedStack}function formatTrace(trace){const logs=[];trace.forEach(((entry,i)=>{logs.push(...i===0?[]:[`\n`],...formatTraceEntry(entry))}));return logs}function formatTraceEntry({vnode:vnode,recurseCount:recurseCount}){const postfix=recurseCount>0?`... (${recurseCount} recursive calls)`:``;const isRoot=vnode.component?vnode.component.parent==null:false;const open=` at <${formatComponentName(vnode.component,vnode.type,isRoot)}`;const close=`>`+postfix;return vnode.props?[open,...formatProps(vnode.props),close]:[open+close]}function formatProps(props){const res=[];const keys=Object.keys(props);keys.slice(0,3).forEach((key=>{res.push(...formatProp(key,props[key]))}));if(keys.length>3){res.push(` ...`)}return res}function formatProp(key,value,raw){if(isString(value)){value=JSON.stringify(value);return raw?value:[`${key}=${value}`]}else if(typeof value==="number"||typeof value==="boolean"||value==null){return raw?value:[`${key}=${value}`]}else if(isRef(value)){value=formatProp(key,toRaw(value.value),true);return raw?value:[`${key}=Ref<`,value,`>`]}else if(isFunction(value)){return[`${key}=fn${value.name?`<${value.name}>`:``}`]}else{value=toRaw(value);return raw?value:[`${key}=`,value]}}function callWithErrorHandling(fn,instance,type,args){let res;try{res=args?fn(...args):fn()}catch(err){handleError(err,instance,type)}return res}function callWithAsyncErrorHandling(fn,instance,type,args){if(isFunction(fn)){const res=callWithErrorHandling(fn,instance,type,args);if(res&&isPromise(res)){res.catch((err=>{handleError(err,instance,type)}))}return res}const values=[];for(let i=0;i<fn.length;i++){values.push(callWithAsyncErrorHandling(fn[i],instance,type,args))}return values}function handleError(err,instance,type,throwInDev=true){const contextVNode=instance?instance.vnode:null;if(instance){let cur=instance.parent;const exposedInstance=instance.proxy;const errorInfo=type;while(cur){const errorCapturedHooks=cur.ec;if(errorCapturedHooks){for(let i=0;i<errorCapturedHooks.length;i++){if(errorCapturedHooks[i](err,exposedInstance,errorInfo)===false){return}}}cur=cur.parent}const appErrorHandler=instance.appContext.config.errorHandler;if(appErrorHandler){callWithErrorHandling(appErrorHandler,null,10,[err,exposedInstance,errorInfo]);return}}logError(err,type,contextVNode,throwInDev)}function logError(err,type,contextVNode,throwInDev=true){{console.error(err)}}let isFlushing=false;let isFlushPending=false;const queue=[];let flushIndex=0;const pendingPreFlushCbs=[];let activePreFlushCbs=null;let preFlushIndex=0;const pendingPostFlushCbs=[];let activePostFlushCbs=null;let postFlushIndex=0;const resolvedPromise=Promise.resolve();let currentFlushPromise=null;let currentPreFlushParentJob=null;function nextTick(fn){const p=currentFlushPromise||resolvedPromise;return fn?p.then(this?fn.bind(this):fn):p}function findInsertionIndex(id2){let start=flushIndex+1;let end=queue.length;while(start<end){const middle=start+end>>>1;const middleJobId=getId(queue[middle]);middleJobId<id2?start=middle+1:end=middle}return start}function queueJob(job){if((!queue.length||!queue.includes(job,isFlushing&&job.allowRecurse?flushIndex+1:flushIndex))&&job!==currentPreFlushParentJob){if(job.id==null){queue.push(job)}else{queue.splice(findInsertionIndex(job.id),0,job)}queueFlush()}}function queueFlush(){if(!isFlushing&&!isFlushPending){isFlushPending=true;currentFlushPromise=resolvedPromise.then(flushJobs)}}function invalidateJob(job){const i=queue.indexOf(job);if(i>flushIndex){queue.splice(i,1)}return i}function queueCb(cb,activeQueue,pendingQueue,index2){if(!isArray(cb)){if(!activeQueue||!activeQueue.includes(cb,cb.allowRecurse?index2+1:index2)){pendingQueue.push(cb)}}else{pendingQueue.push(...cb)}queueFlush()}function queuePreFlushCb(cb){queueCb(cb,activePreFlushCbs,pendingPreFlushCbs,preFlushIndex)}function queuePostFlushCb(cb){queueCb(cb,activePostFlushCbs,pendingPostFlushCbs,postFlushIndex)}function flushPreFlushCbs(seen,parentJob=null){if(pendingPreFlushCbs.length){currentPreFlushParentJob=parentJob;activePreFlushCbs=[...new Set(pendingPreFlushCbs)];pendingPreFlushCbs.length=0;for(preFlushIndex=0;preFlushIndex<activePreFlushCbs.length;preFlushIndex++){activePreFlushCbs[preFlushIndex]()}activePreFlushCbs=null;preFlushIndex=0;currentPreFlushParentJob=null;flushPreFlushCbs(seen,parentJob)}}function flushPostFlushCbs(seen){if(pendingPostFlushCbs.length){const deduped=[...new Set(pendingPostFlushCbs)];pendingPostFlushCbs.length=0;if(activePostFlushCbs){activePostFlushCbs.push(...deduped);return}activePostFlushCbs=deduped;activePostFlushCbs.sort(((a,b)=>getId(a)-getId(b)));for(postFlushIndex=0;postFlushIndex<activePostFlushCbs.length;postFlushIndex++){activePostFlushCbs[postFlushIndex]()}activePostFlushCbs=null;postFlushIndex=0}}const getId=job=>job.id==null?Infinity:job.id;function flushJobs(seen){isFlushPending=false;isFlushing=true;flushPreFlushCbs(seen);queue.sort(((a,b)=>getId(a)-getId(b)));const check=NOOP;try{for(flushIndex=0;flushIndex<queue.length;flushIndex++){const job=queue[flushIndex];if(job&&job.active!==false){if(false);callWithErrorHandling(job,null,14)}}}finally{flushIndex=0;queue.length=0;flushPostFlushCbs();isFlushing=false;currentFlushPromise=null;if(queue.length||pendingPreFlushCbs.length||pendingPostFlushCbs.length){flushJobs(seen)}}}function emit$1(instance,event,...rawArgs){if(instance.isUnmounted)return;const props=instance.vnode.props||EMPTY_OBJ;let args=rawArgs;const isModelListener2=event.startsWith("update:");const modelArg=isModelListener2&&event.slice(7);if(modelArg&&modelArg in props){const modifiersKey=`${modelArg==="modelValue"?"model":modelArg}Modifiers`;const{number:number,trim:trim}=props[modifiersKey]||EMPTY_OBJ;if(trim){args=rawArgs.map((a=>a.trim()))}else if(number){args=rawArgs.map(toNumber)}}let handlerName;let handler=props[handlerName=toHandlerKey(event)]||props[handlerName=toHandlerKey(camelize(event))];if(!handler&&isModelListener2){handler=props[handlerName=toHandlerKey(hyphenate(event))]}if(handler){callWithAsyncErrorHandling(handler,instance,6,args)}const onceHandler=props[handlerName+`Once`];if(onceHandler){if(!instance.emitted){instance.emitted={}}else if(instance.emitted[handlerName]){return}instance.emitted[handlerName]=true;callWithAsyncErrorHandling(onceHandler,instance,6,args)}}function normalizeEmitsOptions(comp,appContext,asMixin=false){const cache=appContext.emitsCache;const cached=cache.get(comp);if(cached!==void 0){return cached}const raw=comp.emits;let normalized={};let hasExtends=false;if(!isFunction(comp)){const extendEmits=raw2=>{const normalizedFromExtend=normalizeEmitsOptions(raw2,appContext,true);if(normalizedFromExtend){hasExtends=true;extend(normalized,normalizedFromExtend)}};if(!asMixin&&appContext.mixins.length){appContext.mixins.forEach(extendEmits)}if(comp.extends){extendEmits(comp.extends)}if(comp.mixins){comp.mixins.forEach(extendEmits)}}if(!raw&&!hasExtends){cache.set(comp,null);return null}if(isArray(raw)){raw.forEach((key=>normalized[key]=null))}else{extend(normalized,raw)}cache.set(comp,normalized);return normalized}function isEmitListener(options,key){if(!options||!isOn(key)){return false}key=key.slice(2).replace(/Once$/,"");return hasOwn(options,key[0].toLowerCase()+key.slice(1))||hasOwn(options,hyphenate(key))||hasOwn(options,key)}let currentRenderingInstance=null;function setCurrentRenderingInstance(instance){const prev=currentRenderingInstance;currentRenderingInstance=instance;instance&&instance.type.__scopeId||null;return prev}function provide(key,value){if(!currentInstance);else{let provides=currentInstance.provides;const parentProvides=currentInstance.parent&&currentInstance.parent.provides;if(parentProvides===provides){provides=currentInstance.provides=Object.create(parentProvides)}provides[key]=value;if(currentInstance.type.mpType==="app"){currentInstance.appContext.app.provide(key,value)}}}function inject(key,defaultValue,treatDefaultAsFactory=false){const instance=currentInstance||currentRenderingInstance;if(instance){const provides=instance.parent==null?instance.vnode.appContext&&instance.vnode.appContext.provides:instance.parent.provides;if(provides&&key in provides){return provides[key]}else if(arguments.length>1){return treatDefaultAsFactory&&isFunction(defaultValue)?defaultValue.call(instance.proxy):defaultValue}else;}}const INITIAL_WATCHER_VALUE={};function watch(source,cb,options){return doWatch(source,cb,options)}function doWatch(source,cb,{immediate:immediate,deep:deep,flush:flush,onTrack:onTrack,onTrigger:onTrigger}=EMPTY_OBJ){const instance=currentInstance;let getter;let forceTrigger=false;let isMultiSource=false;if(isRef(source)){getter=()=>source.value;forceTrigger=isShallow(source)}else if(isReactive(source)){getter=()=>source;deep=true}else if(isArray(source)){isMultiSource=true;forceTrigger=source.some(isReactive);getter=()=>source.map((s=>{if(isRef(s)){return s.value}else if(isReactive(s)){return traverse(s)}else if(isFunction(s)){return callWithErrorHandling(s,instance,2)}else;}))}else if(isFunction(source)){if(cb){getter=()=>callWithErrorHandling(source,instance,2)}else{getter=()=>{if(instance&&instance.isUnmounted){return}if(cleanup){cleanup()}return callWithAsyncErrorHandling(source,instance,3,[onCleanup])}}}else{getter=NOOP}if(cb&&deep){const baseGetter=getter;getter=()=>traverse(baseGetter())}let cleanup;let onCleanup=fn=>{cleanup=effect.onStop=()=>{callWithErrorHandling(fn,instance,4)}};let oldValue=isMultiSource?[]:INITIAL_WATCHER_VALUE;const job=()=>{if(!effect.active){return}if(cb){const newValue=effect.run();if(deep||forceTrigger||(isMultiSource?newValue.some(((v,i)=>hasChanged(v,oldValue[i]))):hasChanged(newValue,oldValue))||false){if(cleanup){cleanup()}callWithAsyncErrorHandling(cb,instance,3,[newValue,oldValue===INITIAL_WATCHER_VALUE?void 0:oldValue,onCleanup]);oldValue=newValue}}else{effect.run()}};job.allowRecurse=!!cb;let scheduler;if(flush==="sync"){scheduler=job}else if(flush==="post"){scheduler=()=>queuePostRenderEffect(job,instance&&instance.suspense)}else{scheduler=()=>{if(!instance||instance.isMounted){queuePreFlushCb(job)}else{job()}}}const effect=new ReactiveEffect(getter,scheduler);if(cb){if(immediate){job()}else{oldValue=effect.run()}}else if(flush==="post"){queuePostRenderEffect(effect.run.bind(effect),instance&&instance.suspense)}else{effect.run()}return()=>{effect.stop();if(instance&&instance.scope){remove(instance.scope.effects,effect)}}}function instanceWatch(source,value,options){const publicThis=this.proxy;const getter=isString(source)?source.includes(".")?createPathGetter(publicThis,source):()=>publicThis[source]:source.bind(publicThis,publicThis);let cb;if(isFunction(value)){cb=value}else{cb=value.handler;options=value}const cur=currentInstance;setCurrentInstance(this);const res=doWatch(getter,cb.bind(publicThis),options);if(cur){setCurrentInstance(cur)}else{unsetCurrentInstance()}return res}function createPathGetter(ctx,path){const segments=path.split(".");return()=>{let cur=ctx;for(let i=0;i<segments.length&&cur;i++){cur=cur[segments[i]]}return cur}}function traverse(value,seen){if(!isObject(value)||value["__v_skip"]){return value}seen=seen||new Set;if(seen.has(value)){return value}seen.add(value);if(isRef(value)){traverse(value.value,seen)}else if(isArray(value)){for(let i=0;i<value.length;i++){traverse(value[i],seen)}}else if(isSet(value)||isMap(value)){value.forEach((v=>{traverse(v,seen)}))}else if(isPlainObject(value)){for(const key in value){traverse(value[key],seen)}}return value}function defineComponent(options){return isFunction(options)?{setup:options,name:options.name}:options}const isKeepAlive=vnode=>vnode.type.__isKeepAlive;function onActivated(hook,target){registerKeepAliveHook(hook,"a",target)}function onDeactivated(hook,target){registerKeepAliveHook(hook,"da",target)}function registerKeepAliveHook(hook,type,target=currentInstance){const wrappedHook=hook.__wdc||(hook.__wdc=()=>{let current=target;while(current){if(current.isDeactivated){return}current=current.parent}return hook()});injectHook(type,wrappedHook,target);if(target){let current=target.parent;while(current&&current.parent){if(isKeepAlive(current.parent.vnode)){injectToKeepAliveRoot(wrappedHook,type,target,current)}current=current.parent}}}function injectToKeepAliveRoot(hook,type,target,keepAliveRoot){const injected=injectHook(type,hook,keepAliveRoot,true);onUnmounted((()=>{remove(keepAliveRoot[type],injected)}),target)}function injectHook(type,hook,target=currentInstance,prepend=false){if(target){if(isRootHook(type)){target=target.root}const hooks=target[type]||(target[type]=[]);const wrappedHook=hook.__weh||(hook.__weh=(...args)=>{if(target.isUnmounted){return}pauseTracking();setCurrentInstance(target);const res=callWithAsyncErrorHandling(hook,target,type,args);unsetCurrentInstance();resetTracking();return res});if(prepend){hooks.unshift(wrappedHook)}else{hooks.push(wrappedHook)}return wrappedHook}}const createHook$1=lifecycle=>(hook,target=currentInstance)=>(!isInSSRComponentSetup||lifecycle==="sp")&&injectHook(lifecycle,hook,target);const onBeforeMount=createHook$1("bm");const onMounted=createHook$1("m");const onBeforeUpdate=createHook$1("bu");const onUpdated=createHook$1("u");const onBeforeUnmount=createHook$1("bum");const onUnmounted=createHook$1("um");const onServerPrefetch=createHook$1("sp");const onRenderTriggered=createHook$1("rtg");const onRenderTracked=createHook$1("rtc");function onErrorCaptured(hook,target=currentInstance){injectHook("ec",hook,target)}let shouldCacheAccess=true;function applyOptions$1(instance){const options=resolveMergedOptions(instance);const publicThis=instance.proxy;const ctx=instance.ctx;shouldCacheAccess=false;if(options.beforeCreate){callHook$1(options.beforeCreate,instance,"bc")}const{data:dataOptions,computed:computedOptions,methods:methods,watch:watchOptions,provide:provideOptions,inject:injectOptions,created:created,beforeMount:beforeMount,mounted:mounted,beforeUpdate:beforeUpdate,updated:updated,activated:activated,deactivated:deactivated,beforeDestroy:beforeDestroy,beforeUnmount:beforeUnmount,destroyed:destroyed,unmounted:unmounted,render:render,renderTracked:renderTracked,renderTriggered:renderTriggered,errorCaptured:errorCaptured,serverPrefetch:serverPrefetch,expose:expose,inheritAttrs:inheritAttrs,components:components,directives:directives,filters:filters}=options;const checkDuplicateProperties=null;if(injectOptions){resolveInjections(injectOptions,ctx,checkDuplicateProperties,instance.appContext.config.unwrapInjectedRef)}if(methods){for(const key in methods){const methodHandler=methods[key];if(isFunction(methodHandler)){{ctx[key]=methodHandler.bind(publicThis)}}}}if(dataOptions){const data=dataOptions.call(publicThis,publicThis);if(!isObject(data));else{instance.data=reactive(data)}}shouldCacheAccess=true;if(computedOptions){for(const key in computedOptions){const opt=computedOptions[key];const get2=isFunction(opt)?opt.bind(publicThis,publicThis):isFunction(opt.get)?opt.get.bind(publicThis,publicThis):NOOP;const set2=!isFunction(opt)&&isFunction(opt.set)?opt.set.bind(publicThis):NOOP;const c=computed$1({get:get2,set:set2});Object.defineProperty(ctx,key,{enumerable:true,configurable:true,get:()=>c.value,set:v=>c.value=v})}}if(watchOptions){for(const key in watchOptions){createWatcher(watchOptions[key],ctx,publicThis,key)}}{if(provideOptions){const provides=isFunction(provideOptions)?provideOptions.call(publicThis):provideOptions;Reflect.ownKeys(provides).forEach((key=>{provide(key,provides[key])}))}}{if(created){callHook$1(created,instance,"c")}}function registerLifecycleHook(register,hook){if(isArray(hook)){hook.forEach((_hook=>register(_hook.bind(publicThis))))}else if(hook){register(hook.bind(publicThis))}}registerLifecycleHook(onBeforeMount,beforeMount);registerLifecycleHook(onMounted,mounted);registerLifecycleHook(onBeforeUpdate,beforeUpdate);registerLifecycleHook(onUpdated,updated);registerLifecycleHook(onActivated,activated);registerLifecycleHook(onDeactivated,deactivated);registerLifecycleHook(onErrorCaptured,errorCaptured);registerLifecycleHook(onRenderTracked,renderTracked);registerLifecycleHook(onRenderTriggered,renderTriggered);registerLifecycleHook(onBeforeUnmount,beforeUnmount);registerLifecycleHook(onUnmounted,unmounted);registerLifecycleHook(onServerPrefetch,serverPrefetch);if(isArray(expose)){if(expose.length){const exposed=instance.exposed||(instance.exposed={});expose.forEach((key=>{Object.defineProperty(exposed,key,{get:()=>publicThis[key],set:val=>publicThis[key]=val})}))}else if(!instance.exposed){instance.exposed={}}}if(render&&instance.render===NOOP){instance.render=render}if(inheritAttrs!=null){instance.inheritAttrs=inheritAttrs}if(components)instance.components=components;if(directives)instance.directives=directives;if(instance.ctx.$onApplyOptions){instance.ctx.$onApplyOptions(options,instance,publicThis)}}function resolveInjections(injectOptions,ctx,checkDuplicateProperties=NOOP,unwrapRef=false){if(isArray(injectOptions)){injectOptions=normalizeInject(injectOptions)}for(const key in injectOptions){const opt=injectOptions[key];let injected;if(isObject(opt)){if("default"in opt){injected=inject(opt.from||key,opt.default,true)}else{injected=inject(opt.from||key)}}else{injected=inject(opt)}if(isRef(injected)){if(unwrapRef){Object.defineProperty(ctx,key,{enumerable:true,configurable:true,get:()=>injected.value,set:v=>injected.value=v})}else{ctx[key]=injected}}else{ctx[key]=injected}}}function callHook$1(hook,instance,type){callWithAsyncErrorHandling(isArray(hook)?hook.map((h=>h.bind(instance.proxy))):hook.bind(instance.proxy),instance,type)}function createWatcher(raw,ctx,publicThis,key){const getter=key.includes(".")?createPathGetter(publicThis,key):()=>publicThis[key];if(isString(raw)){const handler=ctx[raw];if(isFunction(handler)){watch(getter,handler)}}else if(isFunction(raw)){watch(getter,raw.bind(publicThis))}else if(isObject(raw)){if(isArray(raw)){raw.forEach((r=>createWatcher(r,ctx,publicThis,key)))}else{const handler=isFunction(raw.handler)?raw.handler.bind(publicThis):ctx[raw.handler];if(isFunction(handler)){watch(getter,handler,raw)}}}else;}function resolveMergedOptions(instance){const base=instance.type;const{mixins:mixins,extends:extendsOptions}=base;const{mixins:globalMixins,optionsCache:cache,config:{optionMergeStrategies:optionMergeStrategies}}=instance.appContext;const cached=cache.get(base);let resolved;if(cached){resolved=cached}else if(!globalMixins.length&&!mixins&&!extendsOptions){{resolved=base}}else{resolved={};if(globalMixins.length){globalMixins.forEach((m=>mergeOptions(resolved,m,optionMergeStrategies,true)))}mergeOptions(resolved,base,optionMergeStrategies)}cache.set(base,resolved);return resolved}function mergeOptions(to,from,strats,asMixin=false){const{mixins:mixins,extends:extendsOptions}=from;if(extendsOptions){mergeOptions(to,extendsOptions,strats,true)}if(mixins){mixins.forEach((m=>mergeOptions(to,m,strats,true)))}for(const key in from){if(asMixin&&key==="expose");else{const strat=internalOptionMergeStrats[key]||strats&&strats[key];to[key]=strat?strat(to[key],from[key]):from[key]}}return to}const internalOptionMergeStrats={data:mergeDataFn,props:mergeObjectOptions,emits:mergeObjectOptions,methods:mergeObjectOptions,computed:mergeObjectOptions,beforeCreate:mergeAsArray$1,created:mergeAsArray$1,beforeMount:mergeAsArray$1,mounted:mergeAsArray$1,beforeUpdate:mergeAsArray$1,updated:mergeAsArray$1,beforeDestroy:mergeAsArray$1,beforeUnmount:mergeAsArray$1,destroyed:mergeAsArray$1,unmounted:mergeAsArray$1,activated:mergeAsArray$1,deactivated:mergeAsArray$1,errorCaptured:mergeAsArray$1,serverPrefetch:mergeAsArray$1,components:mergeObjectOptions,directives:mergeObjectOptions,watch:mergeWatchOptions,provide:mergeDataFn,inject:mergeInject};function mergeDataFn(to,from){if(!from){return to}if(!to){return from}return function mergedDataFn(){return extend(isFunction(to)?to.call(this,this):to,isFunction(from)?from.call(this,this):from)}}function mergeInject(to,from){return mergeObjectOptions(normalizeInject(to),normalizeInject(from))}function normalizeInject(raw){if(isArray(raw)){const res={};for(let i=0;i<raw.length;i++){res[raw[i]]=raw[i]}return res}return raw}function mergeAsArray$1(to,from){return to?[...new Set([].concat(to,from))]:from}function mergeObjectOptions(to,from){return to?extend(extend(Object.create(null),to),from):from}function mergeWatchOptions(to,from){if(!to)return from;if(!from)return to;const merged=extend(Object.create(null),to);for(const key in from){merged[key]=mergeAsArray$1(to[key],from[key])}return merged}function initProps$1(instance,rawProps,isStateful,isSSR=false){const props={};const attrs={};instance.propsDefaults=Object.create(null);setFullProps(instance,rawProps,props,attrs);for(const key in instance.propsOptions[0]){if(!(key in props)){props[key]=void 0}}if(isStateful){instance.props=isSSR?props:shallowReactive(props)}else{if(!instance.type.props){instance.props=attrs}else{instance.props=props}}instance.attrs=attrs}function updateProps(instance,rawProps,rawPrevProps,optimized){const{props:props,attrs:attrs,vnode:{patchFlag:patchFlag}}=instance;const rawCurrentProps=toRaw(props);const[options]=instance.propsOptions;let hasAttrsChanged=false;if((optimized||patchFlag>0)&&!(patchFlag&16)){if(patchFlag&8){const propsToUpdate=instance.vnode.dynamicProps;for(let i=0;i<propsToUpdate.length;i++){let key=propsToUpdate[i];if(isEmitListener(instance.emitsOptions,key)){continue}const value=rawProps[key];if(options){if(hasOwn(attrs,key)){if(value!==attrs[key]){attrs[key]=value;hasAttrsChanged=true}}else{const camelizedKey=camelize(key);props[camelizedKey]=resolvePropValue(options,rawCurrentProps,camelizedKey,value,instance,false)}}else{if(value!==attrs[key]){attrs[key]=value;hasAttrsChanged=true}}}}}else{if(setFullProps(instance,rawProps,props,attrs)){hasAttrsChanged=true}let kebabKey;for(const key in rawCurrentProps){if(!rawProps||!hasOwn(rawProps,key)&&((kebabKey=hyphenate(key))===key||!hasOwn(rawProps,kebabKey))){if(options){if(rawPrevProps&&(rawPrevProps[key]!==void 0||rawPrevProps[kebabKey]!==void 0)){props[key]=resolvePropValue(options,rawCurrentProps,key,void 0,instance,true)}}else{delete props[key]}}}if(attrs!==rawCurrentProps){for(const key in attrs){if(!rawProps||!hasOwn(rawProps,key)&&true){delete attrs[key];hasAttrsChanged=true}}}}if(hasAttrsChanged){trigger(instance,"set","$attrs")}}function setFullProps(instance,rawProps,props,attrs){const[options,needCastKeys]=instance.propsOptions;let hasAttrsChanged=false;let rawCastValues;if(rawProps){for(let key in rawProps){if(isReservedProp(key)){continue}const value=rawProps[key];let camelKey;if(options&&hasOwn(options,camelKey=camelize(key))){if(!needCastKeys||!needCastKeys.includes(camelKey)){props[camelKey]=value}else{(rawCastValues||(rawCastValues={}))[camelKey]=value}}else if(!isEmitListener(instance.emitsOptions,key)){if(!(key in attrs)||value!==attrs[key]){attrs[key]=value;hasAttrsChanged=true}}}}if(needCastKeys){const rawCurrentProps=toRaw(props);const castValues=rawCastValues||EMPTY_OBJ;for(let i=0;i<needCastKeys.length;i++){const key=needCastKeys[i];props[key]=resolvePropValue(options,rawCurrentProps,key,castValues[key],instance,!hasOwn(castValues,key))}}return hasAttrsChanged}function resolvePropValue(options,props,key,value,instance,isAbsent){const opt=options[key];if(opt!=null){const hasDefault=hasOwn(opt,"default");if(hasDefault&&value===void 0){const defaultValue=opt.default;if(opt.type!==Function&&isFunction(defaultValue)){const{propsDefaults:propsDefaults}=instance;if(key in propsDefaults){value=propsDefaults[key]}else{setCurrentInstance(instance);value=propsDefaults[key]=defaultValue.call(null,props);unsetCurrentInstance()}}else{value=defaultValue}}if(opt[0]){if(isAbsent&&!hasDefault){value=false}else if(opt[1]&&(value===""||value===hyphenate(key))){value=true}}}return value}function normalizePropsOptions(comp,appContext,asMixin=false){const cache=appContext.propsCache;const cached=cache.get(comp);if(cached){return cached}const raw=comp.props;const normalized={};const needCastKeys=[];let hasExtends=false;if(!isFunction(comp)){const extendProps=raw2=>{hasExtends=true;const[props,keys]=normalizePropsOptions(raw2,appContext,true);extend(normalized,props);if(keys)needCastKeys.push(...keys)};if(!asMixin&&appContext.mixins.length){appContext.mixins.forEach(extendProps)}if(comp.extends){extendProps(comp.extends)}if(comp.mixins){comp.mixins.forEach(extendProps)}}if(!raw&&!hasExtends){cache.set(comp,EMPTY_ARR);return EMPTY_ARR}if(isArray(raw)){for(let i=0;i<raw.length;i++){const normalizedKey=camelize(raw[i]);if(validatePropName(normalizedKey)){normalized[normalizedKey]=EMPTY_OBJ}}}else if(raw){for(const key in raw){const normalizedKey=camelize(key);if(validatePropName(normalizedKey)){const opt=raw[key];const prop=normalized[normalizedKey]=isArray(opt)||isFunction(opt)?{type:opt}:opt;if(prop){const booleanIndex=getTypeIndex(Boolean,prop.type);const stringIndex=getTypeIndex(String,prop.type);prop[0]=booleanIndex>-1;prop[1]=stringIndex<0||booleanIndex<stringIndex;if(booleanIndex>-1||hasOwn(prop,"default")){needCastKeys.push(normalizedKey)}}}}}const res=[normalized,needCastKeys];cache.set(comp,res);return res}function validatePropName(key){if(key[0]!=="$"){return true}return false}function getType(ctor){const match=ctor&&ctor.toString().match(/^\s*function (\w+)/);return match?match[1]:ctor===null?"null":""}function isSameType(a,b){return getType(a)===getType(b)}function getTypeIndex(type,expectedTypes){if(isArray(expectedTypes)){return expectedTypes.findIndex((t2=>isSameType(t2,type)))}else if(isFunction(expectedTypes)){return isSameType(expectedTypes,type)?0:-1}return-1}function createAppContext(){return{app:null,config:{isNativeTag:NO,performance:false,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let uid=0;function createAppAPI(render,hydrate){return function createApp2(rootComponent,rootProps=null){if(!isFunction(rootComponent)){rootComponent=Object.assign({},rootComponent)}if(rootProps!=null&&!isObject(rootProps)){rootProps=null}const context=createAppContext();const installedPlugins=new Set;const app=context.app={_uid:uid++,_component:rootComponent,_props:rootProps,_container:null,_context:context,_instance:null,version:version,get config(){return context.config},set config(v){},use(plugin2,...options){if(installedPlugins.has(plugin2));else if(plugin2&&isFunction(plugin2.install)){installedPlugins.add(plugin2);plugin2.install(app,...options)}else if(isFunction(plugin2)){installedPlugins.add(plugin2);plugin2(app,...options)}else;return app},mixin(mixin){{if(!context.mixins.includes(mixin)){context.mixins.push(mixin)}}return app},component(name,component){if(!component){return context.components[name]}context.components[name]=component;return app},directive(name,directive){if(!directive){return context.directives[name]}context.directives[name]=directive;return app},mount(){},unmount(){},provide(key,value){context.provides[key]=value;return app}};return app}}const queuePostRenderEffect=queuePostFlushCb;const getPublicInstance=i=>{if(!i)return null;if(isStatefulComponent(i))return getExposeProxy(i)||i.proxy;return getPublicInstance(i.parent)};const publicPropertiesMap=extend(Object.create(null),{$:i=>i,$el:i=>i.__$el||(i.__$el={}),$data:i=>i.data,$props:i=>i.props,$attrs:i=>i.attrs,$slots:i=>i.slots,$refs:i=>i.refs,$parent:i=>getPublicInstance(i.parent),$root:i=>getPublicInstance(i.root),$emit:i=>i.emit,$options:i=>resolveMergedOptions(i),$forceUpdate:i=>()=>queueJob(i.update),$watch:i=>instanceWatch.bind(i)});const PublicInstanceProxyHandlers={get({_:instance},key){const{ctx:ctx,setupState:setupState,data:data,props:props,accessCache:accessCache,type:type,appContext:appContext}=instance;let normalizedProps;if(key[0]!=="$"){const n=accessCache[key];if(n!==void 0){switch(n){case 1:return setupState[key];case 2:return data[key];case 4:return ctx[key];case 3:return props[key]}}else if(setupState!==EMPTY_OBJ&&hasOwn(setupState,key)){accessCache[key]=1;return setupState[key]}else if(data!==EMPTY_OBJ&&hasOwn(data,key)){accessCache[key]=2;return data[key]}else if((normalizedProps=instance.propsOptions[0])&&hasOwn(normalizedProps,key)){accessCache[key]=3;return props[key]}else if(ctx!==EMPTY_OBJ&&hasOwn(ctx,key)){accessCache[key]=4;return ctx[key]}else if(shouldCacheAccess){accessCache[key]=0}}const publicGetter=publicPropertiesMap[key];let cssModule,globalProperties;if(publicGetter){if(key==="$attrs"){track(instance,"get",key)}return publicGetter(instance)}else if((cssModule=type.__cssModules)&&(cssModule=cssModule[key])){return cssModule}else if(ctx!==EMPTY_OBJ&&hasOwn(ctx,key)){accessCache[key]=4;return ctx[key]}else if(globalProperties=appContext.config.globalProperties,hasOwn(globalProperties,key)){{return globalProperties[key]}}else;},set({_:instance},key,value){const{data:data,setupState:setupState,ctx:ctx}=instance;if(setupState!==EMPTY_OBJ&&hasOwn(setupState,key)){setupState[key]=value;return true}else if(data!==EMPTY_OBJ&&hasOwn(data,key)){data[key]=value;return true}else if(hasOwn(instance.props,key)){return false}if(key[0]==="$"&&key.slice(1)in instance){return false}else{{ctx[key]=value}}return true},has({_:{data:data,setupState:setupState,accessCache:accessCache,ctx:ctx,appContext:appContext,propsOptions:propsOptions}},key){let normalizedProps;return!!accessCache[key]||data!==EMPTY_OBJ&&hasOwn(data,key)||setupState!==EMPTY_OBJ&&hasOwn(setupState,key)||(normalizedProps=propsOptions[0])&&hasOwn(normalizedProps,key)||hasOwn(ctx,key)||hasOwn(publicPropertiesMap,key)||hasOwn(appContext.config.globalProperties,key)},defineProperty(target,key,descriptor){if(descriptor.get!=null){target._.accessCache[key]=0}else if(hasOwn(descriptor,"value")){this.set(target,key,descriptor.value,null)}return Reflect.defineProperty(target,key,descriptor)}};const emptyAppContext=createAppContext();let uid$1=0;function createComponentInstance(vnode,parent,suspense){const type=vnode.type;const appContext=(parent?parent.appContext:vnode.appContext)||emptyAppContext;const instance={uid:uid$1++,vnode:vnode,type:type,parent:parent,appContext:appContext,root:null,next:null,subTree:null,effect:null,update:null,scope:new EffectScope(true),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:parent?parent.provides:Object.create(appContext.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:normalizePropsOptions(type,appContext),emitsOptions:normalizeEmitsOptions(type,appContext),emit:null,emitted:null,propsDefaults:EMPTY_OBJ,inheritAttrs:type.inheritAttrs,ctx:EMPTY_OBJ,data:EMPTY_OBJ,props:EMPTY_OBJ,attrs:EMPTY_OBJ,slots:EMPTY_OBJ,refs:EMPTY_OBJ,setupState:EMPTY_OBJ,setupContext:null,suspense:suspense,suspenseId:suspense?suspense.pendingId:0,asyncDep:null,asyncResolved:false,isMounted:false,isUnmounted:false,isDeactivated:false,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};{instance.ctx={_:instance}}instance.root=parent?parent.root:instance;instance.emit=emit$1.bind(null,instance);if(vnode.ce){vnode.ce(instance)}return instance}let currentInstance=null;const getCurrentInstance=()=>currentInstance||currentRenderingInstance;const setCurrentInstance=instance=>{currentInstance=instance;instance.scope.on()};const unsetCurrentInstance=()=>{currentInstance&&currentInstance.scope.off();currentInstance=null};function isStatefulComponent(instance){return instance.vnode.shapeFlag&4}let isInSSRComponentSetup=false;function setupComponent(instance,isSSR=false){isInSSRComponentSetup=isSSR;const{props:props}=instance.vnode;const isStateful=isStatefulComponent(instance);initProps$1(instance,props,isStateful,isSSR);const setupResult=isStateful?setupStatefulComponent(instance):void 0;isInSSRComponentSetup=false;return setupResult}function setupStatefulComponent(instance,isSSR){const Component2=instance.type;instance.accessCache=Object.create(null);instance.proxy=markRaw(new Proxy(instance.ctx,PublicInstanceProxyHandlers));const{setup:setup}=Component2;if(setup){const setupContext=instance.setupContext=setup.length>1?createSetupContext(instance):null;setCurrentInstance(instance);pauseTracking();const setupResult=callWithErrorHandling(setup,instance,0,[instance.props,setupContext]);resetTracking();unsetCurrentInstance();if(isPromise(setupResult)){setupResult.then(unsetCurrentInstance,unsetCurrentInstance)}else{handleSetupResult(instance,setupResult)}}else{finishComponentSetup(instance)}}function handleSetupResult(instance,setupResult,isSSR){if(isFunction(setupResult)){{instance.render=setupResult}}else if(isObject(setupResult)){instance.setupState=proxyRefs(setupResult)}else;finishComponentSetup(instance)}function finishComponentSetup(instance,isSSR,skipOptions){const Component2=instance.type;if(!instance.render){instance.render=Component2.render||NOOP}{setCurrentInstance(instance);pauseTracking();applyOptions$1(instance);resetTracking();unsetCurrentInstance()}}function createAttrsProxy(instance){return new Proxy(instance.attrs,{get(target,key){track(instance,"get","$attrs");return target[key]}})}function createSetupContext(instance){const expose=exposed=>{instance.exposed=exposed||{}};let attrs;{return{get attrs(){return attrs||(attrs=createAttrsProxy(instance))},slots:instance.slots,emit:instance.emit,expose:expose}}}function getExposeProxy(instance){if(instance.exposed){return instance.exposeProxy||(instance.exposeProxy=new Proxy(proxyRefs(markRaw(instance.exposed)),{get(target,key){if(key in target){return target[key]}return instance.proxy[key]}}))}}const classifyRE=/(?:^|[-_])(\w)/g;const classify=str=>str.replace(classifyRE,(c=>c.toUpperCase())).replace(/[-_]/g,"");function getComponentName(Component2){return isFunction(Component2)?Component2.displayName||Component2.name:Component2.name}function formatComponentName(instance,Component2,isRoot=false){let name=getComponentName(Component2);if(!name&&Component2.__file){const match=Component2.__file.match(/([^/\\]+)\.\w+$/);if(match){name=match[1]}}if(!name&&instance&&instance.parent){const inferFromRegistry=registry=>{for(const key in registry){if(registry[key]===Component2){return key}}};name=inferFromRegistry(instance.components||instance.parent.type.components)||inferFromRegistry(instance.appContext.components)}return name?classify(name):isRoot?`App`:`Anonymous`}const computed$1=(getterOrOptions,debugOptions)=>computed(getterOrOptions,debugOptions,isInSSRComponentSetup);const version="3.2.33";function unwrapper(target){return unref(target)}const ARRAYTYPE="[object Array]";const OBJECTTYPE="[object Object]";function diff(current,pre){const result={};syncKeys(current,pre);_diff(current,pre,"",result);return result}function syncKeys(current,pre){current=unwrapper(current);if(current===pre)return;const rootCurrentType=toTypeString(current);const rootPreType=toTypeString(pre);if(rootCurrentType==OBJECTTYPE&&rootPreType==OBJECTTYPE){for(let key in pre){const currentValue=current[key];if(currentValue===void 0){current[key]=null}else{syncKeys(currentValue,pre[key])}}}else if(rootCurrentType==ARRAYTYPE&&rootPreType==ARRAYTYPE){if(current.length>=pre.length){pre.forEach(((item,index2)=>{syncKeys(current[index2],item)}))}}}function _diff(current,pre,path,result){current=unwrapper(current);if(current===pre)return;const rootCurrentType=toTypeString(current);const rootPreType=toTypeString(pre);if(rootCurrentType==OBJECTTYPE){if(rootPreType!=OBJECTTYPE||Object.keys(current).length<Object.keys(pre).length){setResult(result,path,current)}else{for(let key in current){const currentValue=unwrapper(current[key]);const preValue=pre[key];const currentType=toTypeString(currentValue);const preType=toTypeString(preValue);if(currentType!=ARRAYTYPE&&currentType!=OBJECTTYPE){if(currentValue!=preValue){setResult(result,(path==""?"":path+".")+key,currentValue)}}else if(currentType==ARRAYTYPE){if(preType!=ARRAYTYPE){setResult(result,(path==""?"":path+".")+key,currentValue)}else{if(currentValue.length<preValue.length){setResult(result,(path==""?"":path+".")+key,currentValue)}else{currentValue.forEach(((item,index2)=>{_diff(item,preValue[index2],(path==""?"":path+".")+key+"["+index2+"]",result)}))}}}else if(currentType==OBJECTTYPE){if(preType!=OBJECTTYPE||Object.keys(currentValue).length<Object.keys(preValue).length){setResult(result,(path==""?"":path+".")+key,currentValue)}else{for(let subKey in currentValue){_diff(currentValue[subKey],preValue[subKey],(path==""?"":path+".")+key+"."+subKey,result)}}}}}}else if(rootCurrentType==ARRAYTYPE){if(rootPreType!=ARRAYTYPE){setResult(result,path,current)}else{if(current.length<pre.length){setResult(result,path,current)}else{current.forEach(((item,index2)=>{_diff(item,pre[index2],path+"["+index2+"]",result)}))}}}else{setResult(result,path,current)}}function setResult(result,k,v){result[k]=v}function hasComponentEffect(instance){return queue.includes(instance.update)}function flushCallbacks(instance){const ctx=instance.ctx;const callbacks=ctx.__next_tick_callbacks;if(callbacks&&callbacks.length){if({}.VUE_APP_DEBUG){const mpInstance=ctx.$scope;console.log("["+ +new Date+"]["+(mpInstance.is||mpInstance.route)+"]["+instance.uid+"]:flushCallbacks["+callbacks.length+"]")}const copies=callbacks.slice(0);callbacks.length=0;for(let i=0;i<copies.length;i++){copies[i]()}}}function nextTick$1(instance,fn){const ctx=instance.ctx;if(!ctx.__next_tick_pending&&!hasComponentEffect(instance)){if({}.VUE_APP_DEBUG){const mpInstance=ctx.$scope;console.log("["+ +new Date+"]["+(mpInstance.is||mpInstance.route)+"]["+instance.uid+"]:nextVueTick")}return nextTick(fn&&fn.bind(instance.proxy))}if({}.VUE_APP_DEBUG){const mpInstance=ctx.$scope;console.log("["+ +new Date+"]["+(mpInstance.is||mpInstance.route)+"]["+instance.uid+"]:nextMPTick")}let _resolve;if(!ctx.__next_tick_callbacks){ctx.__next_tick_callbacks=[]}ctx.__next_tick_callbacks.push((()=>{if(fn){callWithErrorHandling(fn.bind(instance.proxy),instance,14)}else if(_resolve){_resolve(instance.proxy)}}));return new Promise((resolve=>{_resolve=resolve}))}function clone(src,seen){src=unwrapper(src);const type=typeof src;if(type==="object"&&src!==null){let copy=seen.get(src);if(typeof copy!=="undefined"){return copy}if(isArray(src)){const len=src.length;copy=new Array(len);seen.set(src,copy);for(let i=0;i<len;i++){copy[i]=clone(src[i],seen)}}else{copy={};seen.set(src,copy);for(const name in src){if(hasOwn(src,name)){copy[name]=clone(src[name],seen)}}}return copy}if(type!=="symbol"){return src}}function deepCopy(src){return clone(src,typeof WeakMap!=="undefined"?new WeakMap:new Map)}function getMPInstanceData(instance,keys){const data=instance.data;const ret=Object.create(null);keys.forEach((key=>{ret[key]=data[key]}));return ret}function patch(instance,data,oldData){if(!data){return}data=deepCopy(data);const ctx=instance.ctx;const mpType=ctx.mpType;if(mpType==="page"||mpType==="component"){data.r0=1;const mpInstance=ctx.$scope;const keys=Object.keys(data);const diffData=diff(data,oldData||getMPInstanceData(mpInstance,keys));if(Object.keys(diffData).length){ctx.__next_tick_pending=true;mpInstance.setData(diffData,(()=>{ctx.__next_tick_pending=false;flushCallbacks(instance)}));flushPreFlushCbs(void 0,instance.update)}else{flushCallbacks(instance)}}}function initAppConfig(appConfig){appConfig.globalProperties.$nextTick=function $nextTick(fn){return nextTick$1(this.$,fn)}}function onApplyOptions(options,instance,publicThis){instance.appContext.config.globalProperties.$applyOptions(options,instance,publicThis);const computedOptions=options.computed;if(computedOptions){const keys=Object.keys(computedOptions);if(keys.length){const ctx=instance.ctx;if(!ctx.$computedKeys){ctx.$computedKeys=[]}ctx.$computedKeys.push(...keys)}}delete instance.ctx.$onApplyOptions}function setRef$1(instance,isUnmount=false){const{setupState:setupState,$templateRefs:$templateRefs,ctx:{$scope:$scope,$mpPlatform:$mpPlatform}}=instance;if($mpPlatform==="mp-alipay"){return}if(!$templateRefs||!$scope){return}if(isUnmount){return $templateRefs.forEach((templateRef=>setTemplateRef(templateRef,null,setupState)))}const doSet=()=>{const mpComponents=$scope.selectAllComponents(".r").concat($scope.selectAllComponents(".r-i-f"));$templateRefs.forEach((templateRef=>setTemplateRef(templateRef,findComponentPublicInstance(mpComponents,templateRef.i),setupState)))};if($scope._$setRef){$scope._$setRef(doSet)}else{nextTick$1(instance,doSet)}}function findComponentPublicInstance(mpComponents,id2){const mpInstance=mpComponents.find((com=>com&&(com.properties||com.props).uI===id2));if(mpInstance){const vm=mpInstance.$vm;return getExposeProxy(vm.$)||vm}return null}function setTemplateRef({r:r,f:f},refValue,setupState){if(isFunction(r)){r(refValue,{})}else{const _isString=isString(r);const _isRef=isRef(r);if(_isString||_isRef){if(f){if(!_isRef){return}if(!isArray(r.value)){r.value=[]}const existing=r.value;if(existing.indexOf(refValue)===-1){existing.push(refValue);if(!refValue){return}onBeforeUnmount((()=>remove(existing,refValue)),refValue.$)}}else if(_isString){if(hasOwn(setupState,r)){setupState[r]=refValue}}else if(isRef(r)){r.value=refValue}else;}}}var MPType;(function(MPType2){MPType2["APP"]="app";MPType2["PAGE"]="page";MPType2["COMPONENT"]="component"})(MPType||(MPType={}));const queuePostRenderEffect$1=queuePostFlushCb;function mountComponent(initialVNode,options){const instance=initialVNode.component=createComponentInstance(initialVNode,options.parentComponent,null);{instance.ctx.$onApplyOptions=onApplyOptions;instance.ctx.$children=[]}if(options.mpType==="app"){instance.render=NOOP}if(options.onBeforeSetup){options.onBeforeSetup(instance,options)}setupComponent(instance);{if(options.parentComponent&&instance.proxy){options.parentComponent.ctx.$children.push(getExposeProxy(instance)||instance.proxy)}}setupRenderEffect(instance);return instance.proxy}const getFunctionalFallthrough=attrs=>{let res;for(const key in attrs){if(key==="class"||key==="style"||isOn(key)){(res||(res={}))[key]=attrs[key]}}return res};function renderComponentRoot(instance){const{type:Component2,vnode:vnode,proxy:proxy,withProxy:withProxy,props:props,propsOptions:[propsOptions],slots:slots,attrs:attrs,emit:emit,render:render,renderCache:renderCache,data:data,setupState:setupState,ctx:ctx,uid:uid2,appContext:{app:{config:{globalProperties:{pruneComponentPropsCache:pruneComponentPropsCache2}}}},inheritAttrs:inheritAttrs}=instance;instance.$templateRefs=[];instance.$ei=0;pruneComponentPropsCache2(uid2);instance.__counter=instance.__counter===0?1:0;let result;const prev=setCurrentRenderingInstance(instance);try{if(vnode.shapeFlag&4){fallthroughAttrs(inheritAttrs,props,propsOptions,attrs);const proxyToUse=withProxy||proxy;result=render.call(proxyToUse,proxyToUse,renderCache,props,setupState,data,ctx)}else{fallthroughAttrs(inheritAttrs,props,propsOptions,Component2.props?attrs:getFunctionalFallthrough(attrs));const render2=Component2;result=render2.length>1?render2(props,{attrs:attrs,slots:slots,emit:emit}):render2(props,null)}}catch(err){handleError(err,instance,1);result=false}setRef$1(instance);setCurrentRenderingInstance(prev);return result}function fallthroughAttrs(inheritAttrs,props,propsOptions,fallthroughAttrs2){if(props&&fallthroughAttrs2&&inheritAttrs!==false){const keys=Object.keys(fallthroughAttrs2).filter((key=>key!=="class"&&key!=="style"));if(!keys.length){return}if(propsOptions&&keys.some(isModelListener)){keys.forEach((key=>{if(!isModelListener(key)||!(key.slice(9)in propsOptions)){props[key]=fallthroughAttrs2[key]}}))}else{keys.forEach((key=>props[key]=fallthroughAttrs2[key]))}}}const updateComponentPreRender=instance=>{pauseTracking();flushPreFlushCbs(void 0,instance.update);resetTracking()};function componentUpdateScopedSlotsFn(){const scopedSlotsData=this.$scopedSlotsData;if(!scopedSlotsData||scopedSlotsData.length===0){return}const mpInstance=this.ctx.$scope;const oldData=mpInstance.data;const diffData=Object.create(null);scopedSlotsData.forEach((({path:path,index:index2,data:data})=>{const oldScopedSlotData=getValueByDataPath(oldData,path);const diffPath=`${path}[${index2}]`;if(typeof oldScopedSlotData==="undefined"||typeof oldScopedSlotData[index2]==="undefined"){diffData[diffPath]=data}else{const diffScopedSlotData=diff(data,oldScopedSlotData[index2]);Object.keys(diffScopedSlotData).forEach((name=>{diffData[diffPath+"."+name]=diffScopedSlotData[name]}))}}));scopedSlotsData.length=0;if(Object.keys(diffData).length){mpInstance.setData(diffData)}}function toggleRecurse({effect:effect,update:update},allowed){effect.allowRecurse=update.allowRecurse=allowed}function setupRenderEffect(instance){const updateScopedSlots=componentUpdateScopedSlotsFn.bind(instance);instance.$updateScopedSlots=()=>nextTick((()=>queueJob(updateScopedSlots)));const componentUpdateFn=()=>{if(!instance.isMounted){onBeforeUnmount((()=>{setRef$1(instance,true)}),instance);patch(instance,renderComponentRoot(instance))}else{const{bu:bu,u:u}=instance;toggleRecurse(instance,false);updateComponentPreRender(instance);if(bu){invokeArrayFns$1(bu)}toggleRecurse(instance,true);patch(instance,renderComponentRoot(instance));if(u){queuePostRenderEffect$1(u)}}};const effect=instance.effect=new ReactiveEffect(componentUpdateFn,(()=>queueJob(instance.update)),instance.scope);const update=instance.update=effect.run.bind(effect);update.id=instance.uid;toggleRecurse(instance,true);update()}function unmountComponent(instance){const{bum:bum,scope:scope,update:update,um:um}=instance;if(bum){invokeArrayFns$1(bum)}scope.stop();if(update){update.active=false}if(um){queuePostRenderEffect$1(um)}queuePostRenderEffect$1((()=>{instance.isUnmounted=true}))}const oldCreateApp=createAppAPI();function createVueApp(rootComponent,rootProps=null){const app=oldCreateApp(rootComponent,rootProps);const appContext=app._context;initAppConfig(appContext.config);const createVNode=initialVNode=>{initialVNode.appContext=appContext;initialVNode.shapeFlag=6;return initialVNode};const createComponent2=function createComponent3(initialVNode,options){return mountComponent(createVNode(initialVNode),options)};const destroyComponent=function destroyComponent2(component){return component&&unmountComponent(component.$)};app.mount=function mount(){rootComponent.render=NOOP;const instance=mountComponent(createVNode({type:rootComponent}),{mpType:MPType.APP,mpInstance:null,parentComponent:null,slots:[],props:null});instance.$app=app;instance.$createComponent=createComponent2;instance.$destroyComponent=destroyComponent;appContext.$appInstance=instance;return instance};app.unmount=function unmount(){warn$1(`Cannot unmount an app.`)};return app}function injectLifecycleHook(name,hook,publicThis,instance){if(isFunction(hook)){injectHook(name,hook.bind(publicThis),instance)}}function initHooks$1(options,instance,publicThis){const mpType=options.mpType||publicThis.$mpType;if(!mpType){return}Object.keys(options).forEach((name=>{if(name.indexOf("on")===0){const hooks=options[name];if(isArray(hooks)){hooks.forEach((hook=>injectLifecycleHook(name,hook,publicThis,instance)))}else{injectLifecycleHook(name,hooks,publicThis,instance)}}}))}function applyOptions(options,instance,publicThis){initHooks$1(options,instance,publicThis)}function set(target,key,val){return target[key]=val}function errorHandler(err,instance,info){if(!instance){throw err}const app=getApp();if(!app||!app.$vm){throw err}{app.$vm.$callHook(ON_ERROR,err,info)}}function mergeAsArray(to,from){return to?[...new Set([].concat(to,from))]:from}function initOptionMergeStrategies(optionMergeStrategies){UniLifecycleHooks.forEach((name=>{optionMergeStrategies[name]=mergeAsArray}))}let realAtob;const b64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";const b64re=/^(?:[A-Za-z\d+/]{4})*?(?:[A-Za-z\d+/]{2}(?:==)?|[A-Za-z\d+/]{3}=?)?$/;if(typeof atob!=="function"){realAtob=function(str){str=String(str).replace(/[\t\n\f\r ]+/g,"");if(!b64re.test(str)){throw new Error("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.")}str+="==".slice(2-(str.length&3));var bitmap;var result="";var r1;var r2;var i=0;for(;i<str.length;){bitmap=b64.indexOf(str.charAt(i++))<<18|b64.indexOf(str.charAt(i++))<<12|(r1=b64.indexOf(str.charAt(i++)))<<6|(r2=b64.indexOf(str.charAt(i++)));result+=r1===64?String.fromCharCode(bitmap>>16&255):r2===64?String.fromCharCode(bitmap>>16&255,bitmap>>8&255):String.fromCharCode(bitmap>>16&255,bitmap>>8&255,bitmap&255)}return result}}else{realAtob=atob}function b64DecodeUnicode(str){return decodeURIComponent(realAtob(str).split("").map((function(c){return"%"+("00"+c.charCodeAt(0).toString(16)).slice(-2)})).join(""))}function getCurrentUserInfo(){const token=index.getStorageSync("uni_id_token")||"";const tokenArr=token.split(".");if(!token||tokenArr.length!==3){return{uid:null,role:[],permission:[],tokenExpired:0}}let userInfo;try{userInfo=JSON.parse(b64DecodeUnicode(tokenArr[1]))}catch(error){throw new Error("获取当前用户信息出错，详细错误信息为："+error.message)}userInfo.tokenExpired=userInfo.exp*1e3;delete userInfo.exp;delete userInfo.iat;return userInfo}function uniIdMixin(globalProperties){globalProperties.uniIDHasRole=function(roleId){const{role:role}=getCurrentUserInfo();return role.indexOf(roleId)>-1};globalProperties.uniIDHasPermission=function(permissionId){const{permission:permission}=getCurrentUserInfo();return this.uniIDHasRole("admin")||permission.indexOf(permissionId)>-1};globalProperties.uniIDTokenValid=function(){const{tokenExpired:tokenExpired}=getCurrentUserInfo();return tokenExpired>Date.now()}}function initApp(app){const appConfig=app._context.config;if(isFunction(app._component.onError)){appConfig.errorHandler=errorHandler}initOptionMergeStrategies(appConfig.optionMergeStrategies);const globalProperties=appConfig.globalProperties;{uniIdMixin(globalProperties)}{globalProperties.$set=set;globalProperties.$applyOptions=applyOptions}{index.invokeCreateVueAppHook(app)}}const propsCaches=Object.create(null);function pruneComponentPropsCache(uid2){delete propsCaches[uid2]}function findComponentPropsData(up){if(!up){return}const[uid2,propsId]=up.split(",");if(!propsCaches[uid2]){return}return propsCaches[uid2][parseInt(propsId)]}var plugin={install(app){initApp(app);app.config.globalProperties.pruneComponentPropsCache=pruneComponentPropsCache;const oldMount=app.mount;app.mount=function mount(rootContainer){const instance=oldMount.call(app,rootContainer);const createApp2=getCreateApp();if(createApp2){createApp2(instance)}else{if(typeof createMiniProgramApp!=="undefined"){createMiniProgramApp(instance)}}return instance}}};function getCreateApp(){const method={}.UNI_MP_PLUGIN?"createPluginApp":{}.UNI_SUBPACKAGE?"createSubpackageApp":"createApp";if(typeof global!=="undefined"){return global[method]}else if(typeof my!=="undefined"){return my[method]}}const t=val=>toDisplayString(val);function createApp$1(rootComponent,rootProps=null){rootComponent&&(rootComponent.mpType="app");return createVueApp(rootComponent,rootProps).use(plugin)}const createSSRApp=createApp$1;const eventChannels={};const eventChannelStack=[];function getEventChannel(id2){if(id2){const eventChannel=eventChannels[id2];delete eventChannels[id2];return eventChannel}return eventChannelStack.shift()}const MP_METHODS=["createSelectorQuery","createIntersectionObserver","selectAllComponents","selectComponent"];function createEmitFn(oldEmit,ctx){return function emit(event,...args){const scope=ctx.$scope;if(scope&&event){const detail={__args__:args};{scope.triggerEvent(event,detail)}}{const props=scope.props;if(props&&props[`on${capitalize(event)}`]){return}}return oldEmit.apply(this,[event,...args])}}function initBaseInstance(instance,options){const ctx=instance.ctx;ctx.mpType=options.mpType;ctx.$mpType=options.mpType;ctx.$mpPlatform="mp-alipay";ctx.$scope=options.mpInstance;ctx.$mp={};{ctx._self={}}instance.slots={};if(isArray(options.slots)&&options.slots.length){options.slots.forEach((name=>{instance.slots[name]=true}));if(instance.slots[SLOT_DEFAULT_NAME]){instance.slots.default=true}}ctx.getOpenerEventChannel=function(){if(!this.__eventChannel__){this.__eventChannel__=new EventChannel}return this.__eventChannel__};ctx.$hasHook=hasHook;ctx.$callHook=callHook;instance.emit=createEmitFn(instance.emit,ctx)}function initComponentInstance(instance,options){initBaseInstance(instance,options);const ctx=instance.ctx;MP_METHODS.forEach((method=>{ctx[method]=function(...args){const mpInstance=ctx.$scope;if(mpInstance&&mpInstance[method]){return mpInstance[method].apply(mpInstance,args)}{return my[method]&&my[method].apply(my,args)}}}))}function initMocks(instance,mpInstance,mocks2){const ctx=instance.ctx;mocks2.forEach((mock=>{if(hasOwn(mpInstance,mock)){instance[mock]=ctx[mock]=mpInstance[mock]}}))}function hasHook(name){const hooks=this.$[name];if(hooks&&hooks.length){return true}return false}function callHook(name,args){if(name==="mounted"){callHook.call(this,"bm");this.$.isMounted=true;name="m"}else if(name==="onLoad"&&args&&args.__id__){this.__eventChannel__=getEventChannel(args.__id__);delete args.__id__}const hooks=this.$[name];return hooks&&invokeArrayFns(hooks,args)}const PAGE_INIT_HOOKS=[ON_LOAD,ON_SHOW,ON_HIDE,ON_UNLOAD,ON_RESIZE,ON_TAB_ITEM_TAP,ON_REACH_BOTTOM,ON_PULL_DOWN_REFRESH,ON_ADD_TO_FAVORITES];function findHooks(vueOptions,hooks=new Set){if(vueOptions){Object.keys(vueOptions).forEach((name=>{if(name.indexOf("on")===0&&isFunction(vueOptions[name])){hooks.add(name)}}));{const{extends:extendsOptions,mixins:mixins}=vueOptions;if(mixins){mixins.forEach((mixin=>findHooks(mixin,hooks)))}if(extendsOptions){findHooks(extendsOptions,hooks)}}}return hooks}function initHook(mpOptions,hook,excludes){if(excludes.indexOf(hook)===-1&&!hasOwn(mpOptions,hook)){mpOptions[hook]=function(args){return this.$vm&&this.$vm.$callHook(hook,args)}}}const EXCLUDE_HOOKS=[ON_READY];function initHooks(mpOptions,hooks,excludes=EXCLUDE_HOOKS){hooks.forEach((hook=>initHook(mpOptions,hook,excludes)))}function initUnknownHooks(mpOptions,vueOptions,excludes=EXCLUDE_HOOKS){findHooks(vueOptions).forEach((hook=>initHook(mpOptions,hook,excludes)))}function initRuntimeHooks(mpOptions,runtimeHooks){if(!runtimeHooks){return}const hooks=Object.keys(MINI_PROGRAM_PAGE_RUNTIME_HOOKS);hooks.forEach((hook=>{if(runtimeHooks&MINI_PROGRAM_PAGE_RUNTIME_HOOKS[hook]){initHook(mpOptions,hook,[])}}))}const HOOKS=[ON_SHOW,ON_HIDE,ON_ERROR,ON_THEME_CHANGE,ON_PAGE_NOT_FOUND,ON_UNHANDLE_REJECTION];function parseApp(instance,parseAppOptions2){const internalInstance=instance.$;const appOptions={globalData:instance.$options&&instance.$options.globalData||{},$vm:instance,onLaunch(options){this.$vm=instance;const ctx=internalInstance.ctx;if(this.$vm&&ctx.$scope){return}initBaseInstance(internalInstance,{mpType:"app",mpInstance:this,slots:[]});ctx.globalData=this.globalData;instance.$callHook(ON_LAUNCH,options)}};initLocale(instance);const vueOptions=instance.$.type;initHooks(appOptions,HOOKS);initUnknownHooks(appOptions,vueOptions);{const methods=vueOptions.methods;methods&&extend(appOptions,methods)}if(parseAppOptions2){parseAppOptions2.parse(appOptions)}return appOptions}function initCreateApp(parseAppOptions2){return function createApp2(vm){return App(parseApp(vm,parseAppOptions2))}}function initCreateSubpackageApp(parseAppOptions2){return function createApp2(vm){const appOptions=parseApp(vm,parseAppOptions2);const app=getApp({allowDefault:true});vm.$.ctx.$scope=app;const globalData=app.globalData;if(globalData){Object.keys(appOptions.globalData).forEach((name=>{if(!hasOwn(globalData,name)){globalData[name]=appOptions.globalData[name]}}))}Object.keys(appOptions).forEach((name=>{if(!hasOwn(app,name)){app[name]=appOptions[name]}}));initAppLifecycle(appOptions,vm);if({}.UNI_SUBPACKAGE){(my.$subpackages||(my.$subpackages={}))[{}.UNI_SUBPACKAGE]={$vm:vm}}}}function initAppLifecycle(appOptions,vm){if(isFunction(appOptions.onLaunch)){const args=my.getLaunchOptionsSync&&my.getLaunchOptionsSync();appOptions.onLaunch(args)}if(isFunction(appOptions.onShow)&&my.onAppShow){my.onAppShow((args=>{vm.$callHook("onShow",args)}))}if(isFunction(appOptions.onHide)&&my.onAppHide){my.onAppHide((args=>{vm.$callHook("onHide",args)}))}}function initLocale(appVm){const locale=ref(my.getSystemInfoSync().language||"zh-Hans");Object.defineProperty(appVm,"$locale",{get(){return locale.value},set(v){locale.value=v}})}function initVueIds(vueIds,mpInstance){if(!vueIds){return}const ids=vueIds.split(",");const len=ids.length;if(len===1){mpInstance._$vueId=ids[0]}else if(len===2){mpInstance._$vueId=ids[0];mpInstance._$vuePid=ids[1]}}function initWxsCallMethods(methods,wxsCallMethods){if(!isArray(wxsCallMethods)){return}wxsCallMethods.forEach((callMethod=>{methods[callMethod]=function(args){return this.$vm[callMethod](args)}}))}function findVmByVueId(instance,vuePid){const $children=instance.$children;for(let i=$children.length-1;i>=0;i--){const childVm=$children[i];if(childVm.$scope._$vueId===vuePid){return childVm}}let parentVm;for(let i=$children.length-1;i>=0;i--){parentVm=findVmByVueId($children[i],vuePid);if(parentVm){return parentVm}}}const builtInProps=["eO","uR","uRIF","uI","uT","uP","uS"];function initDefaultProps(isBehavior=false){const properties={};if(!isBehavior){builtInProps.forEach((name=>{properties[name]={type:null,value:""}}));properties.uS={type:null,value:[],observer:function(newVal){const $slots=Object.create(null);newVal&&newVal.forEach((slotName=>{$slots[slotName]=true}));this.setData({$slots:$slots})}}}return properties}function initProps(mpComponentOptions){if(!mpComponentOptions.properties){mpComponentOptions.properties={}}extend(mpComponentOptions.properties,initDefaultProps())}function findPropsData(properties,isPage){return(isPage?findPagePropsData(properties):findComponentPropsData(properties.uP))||{}}function findPagePropsData(properties){const propsData={};if(isPlainObject(properties)){Object.keys(properties).forEach((name=>{if(builtInProps.indexOf(name)===-1){propsData[name]=properties[name]}}))}return propsData}function initData(_){return{}}function updateComponentProps(up,instance){const prevProps=toRaw(instance.props);const nextProps=findComponentPropsData(up)||{};if(hasPropsChanged(prevProps,nextProps)){updateProps(instance,nextProps,prevProps,false);invalidateJob(instance.update);{instance.update()}}}function hasPropsChanged(prevProps,nextProps,checkLen=true){const nextKeys=Object.keys(nextProps);if(checkLen&&nextKeys.length!==Object.keys(prevProps).length){return true}for(let i=0;i<nextKeys.length;i++){const key=nextKeys[i];if(nextProps[key]!==prevProps[key]){return true}}return false}function initBehaviors(vueOptions){const vueBehaviors=vueOptions.behaviors;let vueProps=vueOptions.props;if(!vueProps){vueOptions.props=vueProps=[]}const behaviors=[];if(isArray(vueBehaviors)){vueBehaviors.forEach((behavior=>{behaviors.push(behavior.replace("uni://","my://"));if(behavior==="uni://form-field"){if(isArray(vueProps)){vueProps.push("name");vueProps.push("value")}else{vueProps.name={type:String,default:""};vueProps.value={type:[String,Number,Boolean,Array,Object,Date],default:""}}}}))}return behaviors}let $createComponentFn;let $destroyComponentFn;function getAppVm(){if({}.UNI_MP_PLUGIN){return my.$vm}if({}.UNI_SUBPACKAGE){return my.$subpackages[{}.UNI_SUBPACKAGE].$vm}return getApp().$vm}function $createComponent(initialVNode,options){if(!$createComponentFn){$createComponentFn=getAppVm().$createComponent}const proxy=$createComponentFn(initialVNode,options);return getExposeProxy(proxy.$)||proxy}function $destroyComponent(instance){if(!$destroyComponentFn){$destroyComponentFn=getApp().$vm.$destroyComponent}return $destroyComponentFn(instance)}function initCreatePluginApp(parseAppOptions2){return function createApp2(vm){initAppLifecycle(parseApp(vm,parseAppOptions2),vm);if({}.UNI_MP_PLUGIN){my.$vm=vm}}}function onAliAuthError(method,$event){$event.type="getphonenumber";$event.detail.errMsg="getPhoneNumber:fail Error: "+$event.detail.errorMessage;method($event)}function onAliGetAuthorize(method,$event){my.getPhoneNumber({success:res=>{$event.type="getphonenumber";const response=JSON.parse(res.response);$event.detail.errMsg="getPhoneNumber:ok";$event.detail.encryptedData=response.response;$event.detail.sign=response.sign;method($event)},fail:res=>{$event.type="getphonenumber";$event.detail.errMsg="getPhoneNumber:fail Error: "+JSON.stringify(res);method($event)}})}function parse(appOptions){const oldOnLaunch=appOptions.onLaunch;appOptions.onLaunch=function onLaunch2(options){oldOnLaunch.call(this,options);if(!this.$vm){return}const globalProperties=this.$vm.$app.config.globalProperties;if(!globalProperties.$onAliAuthError){globalProperties.$onAliAuthError=onAliAuthError;globalProperties.$onAliGetAuthorize=onAliGetAuthorize}}}var parseAppOptions=Object.freeze({__proto__:null,parse:parse});function handleLink$1(event){const detail=event.detail||event.value;const vuePid=detail.vuePid;let parentVm;if(vuePid){parentVm=findVmByVueId(this.$vm,vuePid)}if(!parentVm){parentVm=this.$vm}detail.parent=parentVm}const isComponent2=my.canIUse("component2");const mocks=["$id"];function initRelation(mpInstance,detail){mpInstance.props.onVI(detail)}function initSpecialMethods(mpInstance){if(!mpInstance.$vm){return}let path=mpInstance.is||mpInstance.route;if(!path){return}if(path.indexOf("/")===0){path=path.slice(1)}const specialMethods=my.specialMethods&&my.specialMethods[path];if(specialMethods){specialMethods.forEach((method=>{if(isFunction(mpInstance.$vm[method])){mpInstance[method]=function(event){if(hasOwn(event,"markerId")){event.detail=typeof event.detail==="object"?event.detail:{};event.detail.markerId=event.markerId}mpInstance.$vm[method](event)}}}))}}function initChildVues(mpInstance){if(!mpInstance.$vm){return}const childVues=mpInstance._$childVues;if(childVues){childVues.forEach((relationOptions=>{handleLink$1.call(mpInstance,{detail:relationOptions});const{mpInstance:childMPInstance,createComponent:createComponent2}=relationOptions;childMPInstance.$vm=createComponent2(relationOptions.parent);initSpecialMethods(childMPInstance);if(relationOptions.parent){handleRef.call(relationOptions.parent.$scope,childMPInstance)}initChildVues(childMPInstance);childMPInstance.$vm.$callHook("mounted");childMPInstance.$vm.$callHook(ON_READY)}))}delete mpInstance._$childVues}function handleRef(ref2){if(!ref2){return}const refName=ref2.props.uR;const refInForName=ref2.props.uRIF;if(!refName&&!refInForName){return}const instance=this.$vm.$;const refs=instance.refs===EMPTY_OBJ?instance.refs={}:instance.refs;const{setupState:setupState}=instance;const refValue=ref2.$vm;if(refName){if(isString(refName)){refs[refName]=refValue;if(hasOwn(setupState,refName)){setupState[refName]=refValue}}else{setRef(refName,refValue,refs,setupState)}}else if(refInForName){if(isString(refInForName)){(refs[refInForName]||(refs[refInForName]=[])).push(refValue)}else{setRef(refInForName,refValue,refs,setupState)}}}function isTemplateRef(opts){return!!(opts&&opts.r)}function setRef(ref2,refValue,refs,setupState){if(isRef(ref2)){ref2.value=refValue}else if(isFunction(ref2)){const templateRef=ref2(refValue,refs);if(isTemplateRef(templateRef)){setTemplateRef(templateRef,refValue,setupState)}}}function triggerEvent(type,detail){const handler=this.props[customizeEvent("on-"+type)];if(!handler){return}const target={dataset:{}};handler({type:customizeEvent(type),target:target,currentTarget:target,detail:detail})}function createObserver(isDidUpdate=false){return function observe(props){const nextProps=isDidUpdate?this.props:props;if(nextProps.uP){updateComponentProps(nextProps.uP,this.$vm.$)}}}const handleLink=function(){if(isComponent2){return function handleLink2(detail){return handleLink$1.call(this,{detail:detail})}}return function handleLink2(detail){if(this.$vm&&this.$vm.$.isMounted){return handleLink$1.call(this,{detail:detail})}(this._$childVues||(this._$childVues=[])).unshift(detail)}}();function createVueComponent(mpType,mpInstance,vueOptions,parent){return $createComponent({type:vueOptions,props:findPropsData(mpInstance.props,mpType==="page")},{mpType:mpType,mpInstance:mpInstance,parentComponent:parent&&parent.$,onBeforeSetup(instance,options){initMocks(instance,mpInstance,mocks);initComponentInstance(instance,options)}})}function initCreatePage(){return function createPage2(vueOptions){vueOptions=vueOptions.default||vueOptions;const pageOptions={onLoad(query){this.options=query;this.$page={fullPath:addLeadingSlash(this.route+stringifyQuery(query))};this.props=query;this.$vm=createVueComponent("page",this,vueOptions);initSpecialMethods(this);this.$vm.$callHook(ON_LOAD,query)},onReady(){initChildVues(this);this.$vm.$callHook("mounted");this.$vm.$callHook(ON_READY)},onUnload(){if(this.$vm){this.$vm.$callHook(ON_UNLOAD);$destroyComponent(this.$vm)}},events:{onBack(){this.$vm.$callHook(ON_BACK_PRESS)}},__r:handleRef,__l:handleLink};{pageOptions.data=initData()}initHooks(pageOptions,PAGE_INIT_HOOKS);initUnknownHooks(pageOptions,vueOptions);initRuntimeHooks(pageOptions,vueOptions.__runtimeHooks);initWxsCallMethods(pageOptions,vueOptions.wxsCallMethods);return Page(pageOptions)}}function initComponentProps(_rawProps){const propertiesOptions={properties:{}};initProps(propertiesOptions);const properties=propertiesOptions.properties;const props={onVI:function(){}};Object.keys(properties).forEach((key=>{if(key!=="uS"){props[key]=properties[key].value}}));return props}function initVm(mpInstance,createComponent2){if(mpInstance.$vm){return}const properties=mpInstance.props;initVueIds(properties.uI,mpInstance);const relationOptions={vuePid:mpInstance._$vuePid,mpInstance:mpInstance,createComponent:createComponent2};if(isComponent2){initRelation(mpInstance,relationOptions);mpInstance.$vm=createComponent2(relationOptions.parent)}else{initRelation(mpInstance,relationOptions);if(relationOptions.parent){mpInstance.$vm=createComponent2(relationOptions.parent);handleRef.call(relationOptions.parent.$scope,mpInstance);initChildVues(mpInstance);mpInstance.$vm.$callHook("mounted")}}}function initCreateComponent(){return function createComponent2(vueOptions){vueOptions=vueOptions.default||vueOptions;const mpComponentOptions={props:initComponentProps(vueOptions.props),didMount(){const createComponent3=parent=>createVueComponent("component",this,vueOptions,parent);if(my.dd){setTimeout((()=>{initVm(this,createComponent3)}),4)}else{initVm(this,createComponent3)}initSpecialMethods(this);if(isComponent2){this.$vm.$callHook("mounted")}},didUnmount(){if(this.$vm){pruneComponentPropsCache(this.$vm.$.uid);$destroyComponent(this.$vm)}},methods:{__r:handleRef,__l:handleLink,triggerEvent:triggerEvent}};{mpComponentOptions.data=initData();mpComponentOptions.mixins=initBehaviors(vueOptions)}if(isComponent2){mpComponentOptions.onInit=function onInit(){initVm(this,(parent=>createVueComponent("component",this,vueOptions,parent)))};mpComponentOptions.deriveDataFromProps=createObserver()}else{mpComponentOptions.didUpdate=createObserver(true)}initWxsCallMethods(mpComponentOptions.methods,vueOptions.wxsCallMethods);return Component(mpComponentOptions)}}const createApp=initCreateApp(parseAppOptions);const createPage=initCreatePage();const createComponent=initCreateComponent();const createPluginApp=initCreatePluginApp(parseAppOptions);const createSubpackageApp=initCreateSubpackageApp(parseAppOptions);my.EventChannel=EventChannel;my.createApp=createApp;my.createPage=createPage;my.createComponent=createComponent;my.createPluginApp=createPluginApp;my.createSubpackageApp=createSubpackageApp;const createHook=lifecycle=>(hook,target=getCurrentInstance())=>{!isInSSRComponentSetup&&injectHook(lifecycle,hook,target)};const onShow=createHook(ON_SHOW);const onHide=createHook(ON_HIDE);const onLaunch=createHook(ON_LAUNCH);exports.createSSRApp=createSSRApp;exports.defineComponent=defineComponent;exports.onHide=onHide;exports.onLaunch=onLaunch;exports.onShow=onShow;exports.ref=ref;exports.t=t;
